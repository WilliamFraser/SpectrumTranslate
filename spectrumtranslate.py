import spectrumnumber

#tables of all the opcodes
Z80_OPCODES={
  "base":(
    "NOP","LD BC,nn","LD (BC),A","INC BC","INC B","DEC B","LD B,n","RLCA",
    "EX AF,AF'","ADD HL,BC","LD A,(BC)","DEC BC","INC C","DEC C","LD C,n","RRCA",
    "DJNZ j","LD DE,nn","LD (DE),A","INC DE","INC D","DEC D","LD D,n","RLA",
    "JR j","ADD HL,DE","LD A,(DE)","DEC DE","INC E","DEC E","LD E,n","RRA",
    "JR NZ,j","LD HL,nn","LD (aa),HL","INC HL","INC H","DEC H","LD H,n","DAA",
    "JR Z,j","ADD HL,HL","LD HL,(aa)","DEC HL","INC L","DEC L","LD L,n","CPL",
    "JR NC,j","LD SP,aa","LD (aa),A","INC SP","INC (HL)","DEC (HL)","LD (HL),n","SCF",
    "JR C,j","ADD HL,SP","LD A,(aa)","DEC SP","INC A","DEC A","LD A,n","CCF",
    "LD B,B","LD B,C","LD B,D","LD B,E","LD B,H","LD B,L","LD B,(HL)","LD B,A",
    "LD C,B","LD C,C","LD C,D","LD C,E","LD C,H","LD C,L","LD C,(HL)","LD C,A",
    "LD D,B","LD D,C","LD D,D","LD D,E","LD D,H","LD D,L","LD D,(HL)","LD D,A",
    "LD E,B","LD E,C","LD E,D","LD E,E","LD E,H","LD E,L","LD E,(HL)","LD E,A",
    "LD H,B","LD H,C","LD H,D","LD H,E","LD H,H","LD H,L","LD H,(HL)","LD H,A",
    "LD L,B","LD L,C","LD L,D","LD L,E","LD L,H","LD L,L","LD L,(HL)","LD L,A",
    "LD (HL),B","LD (HL),C","LD (HL),D","LD (HL),E","LD (HL),H","LD (HL),L","HALT","LD (HL),A",
    "LD A,B","LD A,C","LD A,D","LD A,E","LD A,H","LD A,L","LD A,(HL)","LD A,A",
    "ADD A,B","ADD A,C","ADD A,D","ADD A,E","ADD A,H","ADD A,L","ADD A,(HL)","ADD A,A",
    "ADC A,B","ADC A,C","ADC A,D","ADC A,E","ADC A,H","ADC A,L","ADC A,(HL)","ADC A,A",
    "SUB B","SUB C","SUB D","SUB E","SUB H","SUB L","SUB (HL)","SUB A",
    "SBC A,B","SBC A,C","SBC A,D","SBC A,E","SBC A,H","SBC A,L","SBC A,(HL)","SBC A,A",
    "AND B","AND C","AND D","AND E","AND H","AND L","AND (HL)","AND A",
    "XOR B","XOR C","XOR D","XOR E","XOR H","XOR L","XOR (HL)","XOR A",
    "OR B","OR C","OR D","OR E","OR H","OR L","OR (HL)","OR A",
    "CP B","CP C","CP D","CP E","CP H","CP L","CP (HL)","CP A",
    "RET NZ","POP BC","JP NZ,aa","JP aa","CALL NZ,aa","PUSH BC","ADD A,n","RST 00H",
    "RET Z","RET","JP Z,aa",None,"CALL Z,aa","CALL aa","ADC A,n","RST 08H",
    "RET NC","POP DE","JP NC,aa","OUT (n),A","CALL NC,aa","PUSH DE","SUB n","RST 10H",
    "RET C","EXX","JP C,aa","IN A,(n)","CALL C,aa",None,"SBC A,n","RST 18H",
    "RET PO","POP HL","JP PO,aa","EX (SP),HL","CALL PO,aa","PUSH HL","AND n","RST 20H",
    "RET PE","JP HL","JP PE,aa","EX DE,HL","CALL PE,aa",None,"XOR n","RST 28H",
    "RET P","POP AF","JP P,aa","DI","CALL P,aa","PUSH AF","OR n","RST 30H",
    "RET M","LD SP,HL","JP M,aa","EI","CALL M,aa",None,"CP n","RST 38H"),
  "CB":(
    "RLC B","RLC C","RLC D","RLC E","RLC H","RLC L","RLC (HL)","RLC A",
    "RRC B","RRC C","RRC D","RRC E","RRC H","RRC L","RRC (HL)","RRC A",
    "RL B","RL C","RL D","RL E","RL H","RL L","RL (HL)","RL A",
    "RR B","RR C","RR D","RR E","RR H","RR L","RR (HL)","RR A",
    "SLA B","SLA C","SLA D","SLA E","SLA H","SLA L","SLA (HL)","SLA A",
    "SRA B","SRA C","SRA D","SRA E","SRA H","SRA L","SRA (HL)","SRA A",
    "SLL/SL1 B","SLL/SL1 C","SLL/SL1 D","SLL/SL1 E","SLL/SL1 H","SLL/SL1 L","SLL/SL1 (HL)","SLL/SL1 A",
    "SRL B","SRL C","SRL D","SRL E","SRL H","SRL L","SRL (HL)","SRL A",
    "BIT 0,B","BIT 0,C","BIT 0,D","BIT 0,E","BIT 0,H","BIT 0,L","BIT 0,(HL)","BIT 0,A",
    "BIT 1,B","BIT 1,C","BIT 1,D","BIT 1,E","BIT 1,H","BIT 1,L","BIT 1,(HL)","BIT 1,A",
    "BIT 2,B","BIT 2,C","BIT 2,D","BIT 2,E","BIT 2,H","BIT 2,L","BIT 2,(HL)","BIT 2,A",
    "BIT 3,B","BIT 3,C","BIT 3,D","BIT 3,E","BIT 3,H","BIT 3,L","BIT 3,(HL)","BIT 3,A",
    "BIT 4,B","BIT 4,C","BIT 4,D","BIT 4,E","BIT 4,H","BIT 4,L","BIT 4,(HL)","BIT 4,A",
    "BIT 5,B","BIT 5,C","BIT 5,D","BIT 5,E","BIT 5,H","BIT 5,L","BIT 5,(HL)","BIT 5,A",
    "BIT 6,B","BIT 6,C","BIT 6,D","BIT 6,E","BIT 6,H","BIT 6,L","BIT 6,(HL)","BIT 6,A",
    "BIT 7,B","BIT 7,C","BIT 7,D","BIT 7,E","BIT 7,H","BIT 7,L","BIT 7,(HL)","BIT 7,A",
    "RES 0,B","RES 0,C","RES 0,D","RES 0,E","RES 0,H","RES 0,L","RES 0,(HL)","RES 0,A",
    "RES 1,B","RES 1,C","RES 1,D","RES 1,E","RES 1,H","RES 1,L","RES 1,(HL)","RES 1,A",
    "RES 2,B","RES 2,C","RES 2,D","RES 2,E","RES 2,H","RES 2,L","RES 2,(HL)","RES 2,A",
    "RES 3,B","RES 3,C","RES 3,D","RES 3,E","RES 3,H","RES 3,L","RES 3,(HL)","RES 3,A",
    "RES 4,B","RES 4,C","RES 4,D","RES 4,E","RES 4,H","RES 4,L","RES 4,(HL)","RES 4,A",
    "RES 5,B","RES 5,C","RES 5,D","RES 5,E","RES 5,H","RES 5,L","RES 5,(HL)","RES 5,A",
    "RES 6,B","RES 6,C","RES 6,D","RES 6,E","RES 6,H","RES 6,L","RES 6,(HL)","RES 6,A",
    "RES 7,B","RES 7,C","RES 7,D","RES 7,E","RES 7,H","RES 7,L","RES 7,(HL)","RES 7,A",
    "SET 0,B","SET 0,C","SET 0,D","SET 0,E","SET 0,H","SET 0,L","SET 0,(HL)","SET 0,A",
    "SET 1,B","SET 1,C","SET 1,D","SET 1,E","SET 1,H","SET 1,L","SET 1,(HL)","SET 1,A",
    "SET 2,B","SET 2,C","SET 2,D","SET 2,E","SET 2,H","SET 2,L","SET 2,(HL)","SET 2,A",
    "SET 3,B","SET 3,C","SET 3,D","SET 3,E","SET 3,H","SET 3,L","SET 3,(HL)","SET 3,A",
    "SET 4,B","SET 4,C","SET 4,D","SET 4,E","SET 4,H","SET 4,L","SET 4,(HL)","SET 4,A",
    "SET 5,B","SET 5,C","SET 5,D","SET 5,E","SET 5,H","SET 5,L","SET 5,(HL)","SET 5,A",
    "SET 6,B","SET 6,C","SET 6,D","SET 6,E","SET 6,H","SET 6,L","SET 6,(HL)","SET 6,A",
    "SET 7,B","SET 7,C","SET 7,D","SET 7,E","SET 7,H","SET 7,L","SET 7,(HL)","SET 7,A"),
  "DD":(
    None,None,None,None,None,None,None,None,
    None,"ADD IX,BC",None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,"ADD IX,DE",None,None,None,None,None,None,
    None,"LD IX,nn","LD (aa),IX","INC IX","INC IXH","DEC IXH","LD IXH,n",None,
    None,"ADD IX,IX","LD IX,(aa)","DEC IX","INC IXL","DEC IXL","LD IXL,n",None,
    None,None,None,None,"INC (IX+d)","DEC (IX+d)","LD (IX+d),n",None,
    None,"ADD IX,SP",None,None,None,None,None,None,
    None,None,None,None,"LD B,IXH","LD B,IXL","LD B,(IX+d)",None,
    None,None,None,None,"LD C,IXH","LD C,IXL","LD C,(IX+d)",None,
    None,None,None,None,"LD D,IXH","LD D,IXL","LD D,(IX+d)",None,
    None,None,None,None,"LD E,IXH","LD E,IXL","LD E,(IX+d)",None,
    "LD IXH,B","LD IXH,C","LD IXH,D","LD IXH,E","LD IXH,IXH","LD IXH,IXL","LD H,(IX+d)","LD IXH,A",
    "LD IXL,B","LD IXL,C","LD IXL,D","LD IXL,E","LD IXL,IXH","LD IXL,IXL","LD L,(IX+d)","LD IXL,A",
    "LD (IX+d),B","LD (IX+d),C","LD (IX+d),D","LD (IX+d),E","LD (IX+d),H","LD (IX+d),L",None,"LD (IX+d),A",
    None,None,None,None,"LD A,IXH","LD A,IXL","LD A,(IX+d)",None,
    None,None,None,None,"ADD A,IXH","ADD A,IXL","ADD A,(IX+d)",None,
    None,None,None,None,"ADC A,IXH","ADC A,IXL","ADC A,(IX+d)",None,
    None,None,None,None,"SUB IXH","SUB IXL","SUB (IX+d)",None,
    None,None,None,None,"SBC A,IXH","SBC A,IXL","SBC A,(IX+d)",None,
    None,None,None,None,"AND IXH","AND IXL","AND (IX+d)",None,
    None,None,None,None,"XOR IXH","XOR IXL","XOR (IX+d)",None,
    None,None,None,None,"OR IXH","OR IXL","OR (IX+d)",None,
    None,None,None,None,"CP IXH","CP IXL","CP (IX+d)",None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,"POP IX",None,"EX (SP),IX",None,"PUSH IX",None,None,
    None,"JP (IX)",None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,"LD SP,IX",None,None,None,None,None,None),
  "DDCB":(
    "LD B,RLC (IX+d)","LD C,RLC (IX+d)","LD D,RLC (IX+d)","LD E,RLC (IX+d)","LD H,RLC (IX+d)","LD L,RLC (IX+d)","RLC (IX+d)","LD A,RLC (IX+d)",
    "LD B,RRC (IX+d)","LD C,RRC (IX+d)","LD D,RRC (IX+d)","LD E,RRC (IX+d)","LD H,RRC (IX+d)","LD L,RRC (IX+d)","RRC (IX+d)","LD A,RRC (IX+d)",
    "LD B,RL (IX+d)","LD C,RL (IX+d)","LD D,RL (IX+d)","LD E,RL (IX+d)","LD H,RL (IX+d)","LD L,RL (IX+d)","RL (IX+d)","LD A,RL (IX+d)",
    "LD B,RR (IX+d)","LD C,RR (IX+d)","LD D,RR (IX+d)","LD E,RR (IX+d)","LD H,RR (IX+d)","LD L,RR (IX+d)","RR (IX+d)","LD A,RR (IX+d)",
    "LD B,SLA (IX+d)","LD C,SLA (IX+d)","LD D,SLA (IX+d)","LD E,SLA (IX+d)","LD H,SLA (IX+d)","LD L,SLA (IX+d)","SLA (IX+d)","LD A,SLA (IX+d)",
    "LD B,SRA (IX+d)","LD C,SRA (IX+d)","LD D,SRA (IX+d)","LD E,SRA (IX+d)","LD H,SRA (IX+d)","LD L,SRA (IX+d)","SRA (IX+d)","LD A,SRA (IX+d)",
    "LD B,SLL/SL1 (IX+d)","LD C,SLL/SL1 (IX+d)","LD D,SLL/SL1 (IX+d)","LD E,SLL/SL1 (IX+d)","LD H,SLL/SL1 (IX+d)","LD L,SLL/SL1 (IX+d)","SLL/SL1 (IX+d)","LD A,SLL/SL1 (IX+d)",
    "LD B,SRL (IX+d)","LD C,SRL (IX+d)","LD D,SRL (IX+d)","LD E,SRL (IX+d)","LD H,SRL (IX+d)","LD L,SRL (IX+d)","SRL (IX+d)","LD A,SRL (IX+d)",
    "BIT 0,(IX+d)","BIT 0,(IX+d)","BIT 0,(IX+d)","BIT 0,(IX+d)","BIT 0,(IX+d)","BIT 0,(IX+d)","BIT 0,(IX+d)","BIT 0,(IX+d)",
    "BIT 1,(IX+d)","BIT 1,(IX+d)","BIT 1,(IX+d)","BIT 1,(IX+d)","BIT 1,(IX+d)","BIT 1,(IX+d)","BIT 1,(IX+d)","BIT 1,(IX+d)",
    "BIT 2,(IX+d)","BIT 2,(IX+d)","BIT 2,(IX+d)","BIT 2,(IX+d)","BIT 2,(IX+d)","BIT 2,(IX+d)","BIT 2,(IX+d)","BIT 2,(IX+d)",
    "BIT 3,(IX+d)","BIT 3,(IX+d)","BIT 3,(IX+d)","BIT 3,(IX+d)","BIT 3,(IX+d)","BIT 3,(IX+d)","BIT 3,(IX+d)","BIT 3,(IX+d)",
    "BIT 4,(IX+d)","BIT 4,(IX+d)","BIT 4,(IX+d)","BIT 4,(IX+d)","BIT 4,(IX+d)","BIT 4,(IX+d)","BIT 4,(IX+d)","BIT 4,(IX+d)",
    "BIT 5,(IX+d)","BIT 5,(IX+d)","BIT 5,(IX+d)","BIT 5,(IX+d)","BIT 5,(IX+d)","BIT 5,(IX+d)","BIT 5,(IX+d)","BIT 5,(IX+d)",
    "BIT 6,(IX+d)","BIT 6,(IX+d)","BIT 6,(IX+d)","BIT 6,(IX+d)","BIT 6,(IX+d)","BIT 6,(IX+d)","BIT 6,(IX+d)","BIT 6,(IX+d)",
    "BIT 7,(IX+d)","BIT 7,(IX+d)","BIT 7,(IX+d)","BIT 7,(IX+d)","BIT 7,(IX+d)","BIT 7,(IX+d)","BIT 7,(IX+d)","BIT 7,(IX+d)",
    "LD B,RES 0,(IX+d)","LD C,RES 0,(IX+d)","LD D,RES 0,(IX+d)","LD E,RES 0,(IX+d)","LD H,RES 0,(IX+d)","LD L,RES 0,(IX+d)","RES 0,(IX+d)","LD A,RES 0,(IX+d)",
    "LD B,RES 1,(IX+d)","LD C,RES 1,(IX+d)","LD D,RES 1,(IX+d)","LD E,RES 1,(IX+d)","LD H,RES 1,(IX+d)","LD L,RES 1,(IX+d)","RES 1,(IX+d)","LD A,RES 1,(IX+d)",
    "LD B,RES 2,(IX+d)","LD C,RES 2,(IX+d)","LD D,RES 2,(IX+d)","LD E,RES 2,(IX+d)","LD H,RES 2,(IX+d)","LD L,RES 2,(IX+d)","RES 2,(IX+d)","LD A,RES 2,(IX+d)",
    "LD B,RES 3,(IX+d)","LD C,RES 3,(IX+d)","LD D,RES 3,(IX+d)","LD E,RES 3,(IX+d)","LD H,RES 3,(IX+d)","LD L,RES 3,(IX+d)","RES 3,(IX+d)","LD A,RES 3,(IX+d)",
    "LD B,RES 4,(IX+d)","LD C,RES 4,(IX+d)","LD D,RES 4,(IX+d)","LD E,RES 4,(IX+d)","LD H,RES 4,(IX+d)","LD L,RES 4,(IX+d)","RES 4,(IX+d)","LD A,RES 4,(IX+d)",
    "LD B,RES 5,(IX+d)","LD C,RES 5,(IX+d)","LD D,RES 5,(IX+d)","LD E,RES 5,(IX+d)","LD H,RES 5,(IX+d)","LD L,RES 5,(IX+d)","RES 5,(IX+d)","LD A,RES 5,(IX+d)",
    "LD B,RES 6,(IX+d)","LD C,RES 6,(IX+d)","LD D,RES 6,(IX+d)","LD E,RES 6,(IX+d)","LD H,RES 6,(IX+d)","LD L,RES 6,(IX+d)","RES 6,(IX+d)","LD A,RES 6,(IX+d)",
    "LD B,RES 7,(IX+d)","LD C,RES 7,(IX+d)","LD D,RES 7,(IX+d)","LD E,RES 7,(IX+d)","LD H,RES 7,(IX+d)","LD L,RES 7,(IX+d)","RES 7,(IX+d)","LD A,RES 7,(IX+d)",
    "LD B,SET 0,(IX+d)","LD C,SET 0,(IX+d)","LD D,SET 0,(IX+d)","LD E,SET 0,(IX+d)","LD H,SET 0,(IX+d)","LD L,SET 0,(IX+d)","SET 0,(IX+d)","LD A,SET 0,(IX+d)",
    "LD B,SET 1,(IX+d)","LD C,SET 1,(IX+d)","LD D,SET 1,(IX+d)","LD E,SET 1,(IX+d)","LD H,SET 1,(IX+d)","LD L,SET 1,(IX+d)","SET 1,(IX+d)","LD A,SET 1,(IX+d)",
    "LD B,SET 2,(IX+d)","LD C,SET 2,(IX+d)","LD D,SET 2,(IX+d)","LD E,SET 2,(IX+d)","LD H,SET 2,(IX+d)","LD L,SET 2,(IX+d)","SET 2,(IX+d)","LD A,SET 2,(IX+d)",
    "LD B,SET 3,(IX+d)","LD C,SET 3,(IX+d)","LD D,SET 3,(IX+d)","LD E,SET 3,(IX+d)","LD H,SET 3,(IX+d)","LD L,SET 3,(IX+d)","SET 3,(IX+d)","LD A,SET 3,(IX+d)",
    "LD B,SET 4,(IX+d)","LD C,SET 4,(IX+d)","LD D,SET 4,(IX+d)","LD E,SET 4,(IX+d)","LD H,SET 4,(IX+d)","LD L,SET 4,(IX+d)","SET 4,(IX+d)","LD A,SET 4,(IX+d)",
    "LD B,SET 5,(IX+d)","LD C,SET 5,(IX+d)","LD D,SET 5,(IX+d)","LD E,SET 5,(IX+d)","LD H,SET 5,(IX+d)","LD L,SET 5,(IX+d)","SET 5,(IX+d)","LD A,SET 5,(IX+d)",
    "LD B,SET 6,(IX+d)","LD C,SET 6,(IX+d)","LD D,SET 6,(IX+d)","LD E,SET 6,(IX+d)","LD H,SET 6,(IX+d)","LD L,SET 6,(IX+d)","SET 6,(IX+d)","LD A,SET 6,(IX+d)",
    "LD B,SET 7,(IX+d)","LD C,SET 7,(IX+d)","LD D,SET 7,(IX+d)","LD E,SET 7,(IX+d)","LD H,SET 7,(IX+d)","LD L,SET 7,(IX+d)","SET 7,(IX+d)","LD A,SET 7,(IX+d)"),
  "ED":(
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    "IN B,(C)","OUT (C),B","SBC HL,BC","LD (aa),BC","NEG","RETN","IM 0","LD I,A",
    "IN C,(C)","OUT (C),C","ADC HL,BC","LD BC,(aa)","NEG","RETI","IM 0/1","LD R,A",
    "IN D,(C)","OUT (C),D","SBC HL,DE","LD (aa),DE","NEG","RETN","IM 1","LD A,I",
    "IN E,(C)","OUT (C),E","ADC HL,DE","LD DE,(aa)","NEG","RETN","IM 2","LD A,R",
    "IN H,(C)","OUT (C),H","SBC HL,HL","LD (aa),HL","NEG","RETN","IM 0","RRD",
    "IN L,(C)","OUT (C),L","ADC HL,HL","LD HL,(aa)","NEG","RETN","IM 0/1","RLD",
    "IN F,(C) / IN (C)","OUT (C),0","SBC HL,SP","LD (aa),SP","NEG","RETN","IM 1",None,
    "IN A,(C)","OUT (C),A","ADC HL,SP","LD SP,(aa)","NEG","RETN","IM 2",None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    "LDI","CPI","INI","OUTI",None,None,None,None,
    "LDD","CPD","IND","OUTD",None,None,None,None,
    "LDIR","CPIR","INIR","OTIR",None,None,None,None,
    "LDDR","CPDR","INDR","OTDR",None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None),
  "FD":(
    None,None,None,None,None,None,None,None,
    None,"ADD IY,BC",None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,"ADD IY,DE",None,None,None,None,None,None,
    None,"LD IY,nn","LD (aa),IY","INC IY","INC IYH","DEC IYH","LD IYH,n",None,
    None,"ADD IY,IY","LD IY,(aa)","DEC IY","INC IYL","DEC IYL","LD IYL,n",None,
    None,None,None,None,"INC (IY+d)","DEC (IY+d)","LD (IY+d),n",None,
    None,"ADD IY,SP",None,None,None,None,None,None,
    None,None,None,None,"LD B,IYH","LD B,IYL","LD B,(IY+d)",None,
    None,None,None,None,"LD C,IYH","LD C,IYL","LD C,(IY+d)",None,
    None,None,None,None,"LD D,IYH","LD D,IYL","LD D,(IY+d)",None,
    None,None,None,None,"LD E,IYH","LD E,IYL","LD E,(IY+d)",None,
    "LD IYH,B","LD IYH,C","LD IYH,D","LD IYH,E","LD IYH,IYH","LD IYH,IYL","LD H,(IY+d)","LD IYH,A",
    "LD IYL,B","LD IYL,C","LD IYL,D","LD IYL,E","LD IYL,IYH","LD IYL,IYL","LD L,(IY+d)","LD IYL,A",
    "LD (IY+d),B","LD (IY+d),C","LD (IY+d),D","LD (IY+d),E","LD (IY+d),H","LD (IY+d),L",None,"LD (IY+d),A",
    None,None,None,None,"LD A,IYH","LD A,IYL","LD A,(IY+d)",None,
    None,None,None,None,"ADD A,IYH","ADD A,IYL","ADD A,(IY+d)",None,
    None,None,None,None,"ADC A,IYH","ADC A,IYL","ADC A,(IY+d)",None,
    None,None,None,None,"SUB IYH","SUB IYL","SUB (IY+d)",None,
    None,None,None,None,"SBC A,IYH","SBC A,IYL","SBC A,(IY+d)",None,
    None,None,None,None,"AND IYH","AND IYL","AND (IY+d)",None,
    None,None,None,None,"XOR IYH","XOR IYL","XOR (IY+d)",None,
    None,None,None,None,"OR IYH","OR IYL","OR (IY+d)",None,
    None,None,None,None,"CP IYH","CP IYL","CP (IY+d)",None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,"POP IY",None,"EX (SP),IY",None,"PUSH IY",None,None,
    None,"JP (IY)",None,None,None,None,None,None,
    None,None,None,None,None,None,None,None,
    None,"LD SP,IY",None,None,None,None,None,None),
  "FDCB":(
    "LD B,RLC (IY+d)","LD C,RLC (IY+d)","LD D,RLC (IY+d)","LD E,RLC (IY+d)","LD H,RLC (IY+d)","LD L,RLC (IY+d)","RLC (IY+d)","LD A,RLC (IY+d)",
    "LD B,RRC (IY+d)","LD C,RRC (IY+d)","LD D,RRC (IY+d)","LD E,RRC (IY+d)","LD H,RRC (IY+d)","LD L,RRC (IY+d)","RRC (IY+d)","LD A,RRC (IY+d)",
    "LD B,RL (IY+d)","LD C,RL (IY+d)","LD D,RL (IY+d)","LD E,RL (IY+d)","LD H,RL (IY+d)","LD L,RL (IY+d)","RL (IY+d)","LD A,RL (IY+d)",
    "LD B,RR (IY+d)","LD C,RR (IY+d)","LD D,RR (IY+d)","LD E,RR (IY+d)","LD H,RR (IY+d)","LD L,RR (IY+d)","RR (IY+d)","LD A,RR (IY+d)",
    "LD B,SLA (IY+d)","LD C,SLA (IY+d)","LD D,SLA (IY+d)","LD E,SLA (IY+d)","LD H,SLA (IY+d)","LD L,SLA (IY+d)","SLA (IY+d)","LD A,SLA (IY+d)",
    "LD B,SRA (IY+d)","LD C,SRA (IY+d)","LD D,SRA (IY+d)","LD E,SRA (IY+d)","LD H,SRA (IY+d)","LD L,SRA (IY+d)","SRA (IY+d)","LD A,SRA (IY+d)",
    "LD B,SLL/SL1 (IY+d)","LD C,SLL/SL1 (IY+d)","LD D,SLL/SL1 (IY+d)","LD E,SLL/SL1 (IY+d)","LD H,SLL/SL1 (IY+d)","LD L,SLL/SL1 (IY+d)","SLL/SL1 (IY+d)","LD A,SLL/SL1 (IY+d)",
    "LD B,SRL (IY+d)","LD C,SRL (IY+d)","LD D,SRL (IY+d)","LD E,SRL (IY+d)","LD H,SRL (IY+d)","LD L,SRL (IY+d)","SRL (IY+d)","LD A,SRL (IY+d)",
    "BIT 0,(IY+d)","BIT 0,(IY+d)","BIT 0,(IY+d)","BIT 0,(IY+d)","BIT 0,(IY+d)","BIT 0,(IY+d)","BIT 0,(IY+d)","BIT 0,(IY+d)",
    "BIT 1,(IY+d)","BIT 1,(IY+d)","BIT 1,(IY+d)","BIT 1,(IY+d)","BIT 1,(IY+d)","BIT 1,(IY+d)","BIT 1,(IY+d)","BIT 1,(IY+d)",
    "BIT 2,(IY+d)","BIT 2,(IY+d)","BIT 2,(IY+d)","BIT 2,(IY+d)","BIT 2,(IY+d)","BIT 2,(IY+d)","BIT 2,(IY+d)","BIT 2,(IY+d)",
    "BIT 3,(IY+d)","BIT 3,(IY+d)","BIT 3,(IY+d)","BIT 3,(IY+d)","BIT 3,(IY+d)","BIT 3,(IY+d)","BIT 3,(IY+d)","BIT 3,(IY+d)",
    "BIT 4,(IY+d)","BIT 4,(IY+d)","BIT 4,(IY+d)","BIT 4,(IY+d)","BIT 4,(IY+d)","BIT 4,(IY+d)","BIT 4,(IY+d)","BIT 4,(IY+d)",
    "BIT 5,(IY+d)","BIT 5,(IY+d)","BIT 5,(IY+d)","BIT 5,(IY+d)","BIT 5,(IY+d)","BIT 5,(IY+d)","BIT 5,(IY+d)","BIT 5,(IY+d)",
    "BIT 6,(IY+d)","BIT 6,(IY+d)","BIT 6,(IY+d)","BIT 6,(IY+d)","BIT 6,(IY+d)","BIT 6,(IY+d)","BIT 6,(IY+d)","BIT 6,(IY+d)",
    "BIT 7,(IY+d)","BIT 7,(IY+d)","BIT 7,(IY+d)","BIT 7,(IY+d)","BIT 7,(IY+d)","BIT 7,(IY+d)","BIT 7,(IY+d)","BIT 7,(IY+d)",
    "LD B,RES 0,(IY+d)","LD C,RES 0,(IY+d)","LD D,RES 0,(IY+d)","LD E,RES 0,(IY+d)","LD H,RES 0,(IY+d)","LD L,RES 0,(IY+d)","RES 0,(IY+d)","LD A,RES 0,(IY+d)",
    "LD B,RES 1,(IY+d)","LD C,RES 1,(IY+d)","LD D,RES 1,(IY+d)","LD E,RES 1,(IY+d)","LD H,RES 1,(IY+d)","LD L,RES 1,(IY+d)","RES 1,(IY+d)","LD A,RES 1,(IY+d)",
    "LD B,RES 2,(IY+d)","LD C,RES 2,(IY+d)","LD D,RES 2,(IY+d)","LD E,RES 2,(IY+d)","LD H,RES 2,(IY+d)","LD L,RES 2,(IY+d)","RES 2,(IY+d)","LD A,RES 2,(IY+d)",
    "LD B,RES 3,(IY+d)","LD C,RES 3,(IY+d)","LD D,RES 3,(IY+d)","LD E,RES 3,(IY+d)","LD H,RES 3,(IY+d)","LD L,RES 3,(IY+d)","RES 3,(IY+d)","LD A,RES 3,(IY+d)",
    "LD B,RES 4,(IY+d)","LD C,RES 4,(IY+d)","LD D,RES 4,(IY+d)","LD E,RES 4,(IY+d)","LD H,RES 4,(IY+d)","LD L,RES 4,(IY+d)","RES 4,(IY+d)","LD A,RES 4,(IY+d)",
    "LD B,RES 5,(IY+d)","LD C,RES 5,(IY+d)","LD D,RES 5,(IY+d)","LD E,RES 5,(IY+d)","LD H,RES 5,(IY+d)","LD L,RES 5,(IY+d)","RES 5,(IY+d)","LD A,RES 5,(IY+d)",
    "LD B,RES 6,(IY+d)","LD C,RES 6,(IY+d)","LD D,RES 6,(IY+d)","LD E,RES 6,(IY+d)","LD H,RES 6,(IY+d)","LD L,RES 6,(IY+d)","RES 6,(IY+d)","LD A,RES 6,(IY+d)",
    "LD B,RES 7,(IY+d)","LD C,RES 7,(IY+d)","LD D,RES 7,(IY+d)","LD E,RES 7,(IY+d)","LD H,RES 7,(IY+d)","LD L,RES 7,(IY+d)","RES 7,(IY+d)","LD A,RES 7,(IY+d)",
    "LD B,SET 0,(IY+d)","LD C,SET 0,(IY+d)","LD D,SET 0,(IY+d)","LD E,SET 0,(IY+d)","LD H,SET 0,(IY+d)","LD L,SET 0,(IY+d)","SET 0,(IY+d)","LD A,SET 0,(IY+d)",
    "LD B,SET 1,(IY+d)","LD C,SET 1,(IY+d)","LD D,SET 1,(IY+d)","LD E,SET 1,(IY+d)","LD H,SET 1,(IY+d)","LD L,SET 1,(IY+d)","SET 1,(IY+d)","LD A,SET 1,(IY+d)",
    "LD B,SET 2,(IY+d)","LD C,SET 2,(IY+d)","LD D,SET 2,(IY+d)","LD E,SET 2,(IY+d)","LD H,SET 2,(IY+d)","LD L,SET 2,(IY+d)","SET 2,(IY+d)","LD A,SET 2,(IY+d)",
    "LD B,SET 3,(IY+d)","LD C,SET 3,(IY+d)","LD D,SET 3,(IY+d)","LD E,SET 3,(IY+d)","LD H,SET 3,(IY+d)","LD L,SET 3,(IY+d)","SET 3,(IY+d)","LD A,SET 3,(IY+d)",
    "LD B,SET 4,(IY+d)","LD C,SET 4,(IY+d)","LD D,SET 4,(IY+d)","LD E,SET 4,(IY+d)","LD H,SET 4,(IY+d)","LD L,SET 4,(IY+d)","SET 4,(IY+d)","LD A,SET 4,(IY+d)",
    "LD B,SET 5,(IY+d)","LD C,SET 5,(IY+d)","LD D,SET 5,(IY+d)","LD E,SET 5,(IY+d)","LD H,SET 5,(IY+d)","LD L,SET 5,(IY+d)","SET 5,(IY+d)","LD A,SET 5,(IY+d)",
    "LD B,SET 6,(IY+d)","LD C,SET 6,(IY+d)","LD D,SET 6,(IY+d)","LD E,SET 6,(IY+d)","LD H,SET 6,(IY+d)","LD L,SET 6,(IY+d)","SET 6,(IY+d)","LD A,SET 6,(IY+d)",
    "LD B,SET 7,(IY+d)","LD C,SET 7,(IY+d)","LD D,SET 7,(IY+d)","LD E,SET 7,(IY+d)","LD H,SET 7,(IY+d)","LD L,SET 7,(IY+d)","SET 7,(IY+d)","LD A,SET 7,(IY+d)")
}

"""
up to 6 machine states per command so 3 bits to code xxx
4 possible machine state lengths (3,4,5,6) so 2 bits and up to 6 of them: aa bb cc dd ee ff
2 possible machine command lengths so length 2 yyy, state lengths2 gg hh ii jj kk ll
flag to say if machine command time state lengths unknown z=1 then T value in ffeeddccbbaaxxx as number and same for llkkjjiihhggyyy

2 bits to hold if new line needed after command mm

flags: Sign, Zero, Halfcarry, Parity/overflow, N add/subtract, Carry
values for each flag:
  0=flag is non-standardly changed (? in string)
  1=flag is unafected              (- in string)
  2=flag is set as you'd expect    (+ in string)
  3=flag is reset                  (0 in string)
  4=flag is set                    (1 in string)
for parity overflow: 2 other options
  5=flag is set as per parity      (P in string)
  6=flag is set as per overflow    (V in string)

 3 bits to hold Carry nnn
 3 bits to hold add/subtract ooo
 3 bits to hold parity/overflow ppp
 3 bits to hold halfcarry qqq
 3 bits to hold zero rrr
 3 bits to hold sign sss

1 bit to indicate if have flags t

1 bit to indicate if undocumented command u


long format:

    48 47    40 39    32 31    24 23    16 15     8 7      0
     | |      | |      | |      | |      | |      | |      |
 utsss rrrqqqpp pooonnnm mzllkkjj iihhggyy yffeeddc cbbaaxxx
"""
Z80_OPCODE_DATA={
  "base":(
    2573484274221065L,2573484274221067L,2573484274221066L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2582426396131337L,
    2895168734756873L,2578028349620267L,2573484274221066L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2582426396131337L,
    2573486422294803L,2573484274221067L,2573484274221066L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2582426396131337L,
    2573488569188619L,2578028349620267L,2573484274221066L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2582426396131337L,
    2573486422032651L,2573484274221067L,2573484274221069L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2887936009830409L,
    2573486422032651L,2578028349620267L,2573484274221069L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2586884572184585L,
    2573486422032651L,2573484274221067L,2573484274221068L,2573484274221081L,2897427887554571L,2897496607031339L,2573484274221067L,2582443576000521L,
    2573486422032651L,2578028349620267L,2573484274221068L,2573484274221081L,2897427887554569L,2897496607031305L,2573484274221066L,2569232256598025L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2573484274221066L,2573484274221066L,2573484274221066L,2573484274221066L,2573484274221066L,2573484274221066L,2573484274221065L,2573484274221066L,
    2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221065L,2573484274221066L,2573484274221065L,
    2897436477489161L,2897436477489161L,2897436477489161L,2897436477489161L,2897436477489161L,2897436477489161L,2897436477489162L,2897436477489161L,
    2897436477489161L,2897436477489161L,2897436477489161L,2897436477489161L,2897436477489161L,2897436477489161L,2897436477489162L,2897436477489161L,
    2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965898L,2897505196965897L,
    2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965898L,2897505196965897L,
    2905691404632073L,2905691404632073L,2905691404632073L,2905691404632073L,2905691404632073L,2905691404632073L,2905691404632074L,2905691404632073L,
    2901293358120969L,2901293358120969L,2901293358120969L,2901293358120969L,2901293358120969L,2901293358120969L,2901293358120970L,2901293358120969L,
    2901293358120969L,2901293358120969L,2901293358120969L,2901293358120969L,2901293358120969L,2901293358120969L,2901293358120970L,2901293358120969L,
    2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965897L,2897505196965898L,2897505196965897L,
    2573486422261779L,2573484274221067L,2573486421704715L,2573488569188363L,2573484274581645L,2573484274221075L,2897436477489162L,2573484274221075L,
    2573486422261779L,2573488569188363L,2573486421704715L,0L,2573484274581645L,2573484274221197L,2897436477489162L,2573484274221075L,
    2573486422261779L,2573484274221067L,2573486421704715L,2573484274221195L,2573484274581645L,2573484274221075L,2897505196965898L,2573484274221075L,
    2573486422261779L,2573484274221065L,2573486421704715L,2573484274221195L,2573484274581645L,0L,2897505196965898L,2573484274221075L,
    2573486422261779L,2573484274221067L,2573486421704715L,2573484274225293L,2573484274581645L,2573484274221075L,2905691404632074L,2573484274221075L,
    2573486422261779L,2573488569188361L,2573486421704715L,2573484274221065L,2573484274581645L,0L,2901293358120970L,2573484274221075L,
    2573486422261779L,2895168734756875L,2573486421704715L,2573484274221065L,2573484274581645L,2573484274221075L,2901293358120970L,2573484274221075L,
    2573486422261779L,2573484274221081L,2573486421704715L,2573484274221065L,2573484274581645L,0L,2897505196965898L,2573484274221075L),
  "CB":(
    2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186540L,2901284768186410L,
    2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186540L,2901284768186410L,
    2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186540L,2901284768186410L,
    2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186540L,2901284768186410L,
    2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186540L,2901284768186410L,
    2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186410L,2901284768186540L,2901284768186410L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,
    3182759744897066L,3182759744897066L,3182759744897066L,3182759744897066L,3182759744897066L,3182759744897066L,3182759744897196L,3182759744897066L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272170L,2339975492272299L,2339975492272170L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L,
    2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221098L,2573484274221228L,2573484274221098L),
  "DD":(
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2578028349620396L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2578028349620396L,0L,0L,0L,0L,0L,0L,
    0L,2573484274221100L,2573484274221102L,2573484274221162L,4503600701112320L,4503600701112320L,7077084975333376L,0L,
    0L,2578028349620396L,2573484274221102L,2573484274221162L,4503600701112320L,4503600701112320L,7077084975333376L,0L,
    0L,0L,0L,0L,2897427887557678L,2897496607034414L,2573484274222125L,0L,
    0L,2578028349620396L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274222125L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274222125L,7077084975333376L,
    2573484274222125L,2573484274222125L,2573484274222125L,2573484274222125L,2573484274222125L,2573484274222125L,0L,2573484274222125L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897436477490221L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897436477490221L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897505196966957L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897505196966957L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2905691404633133L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2901293358122029L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2901293358122029L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897505196966957L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2573484274221100L,0L,2573484274237998L,0L,2573484274221132L,0L,0L,
    0L,2573488569188394L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2573484274221162L,0L,0L,0L,0L,0L,0L),
  "DDCB":(
    7404885469298688L,7404885469298688L,7404885469298688L,7404885469298688L,7404885469298688L,7404885469298688L,2901284768189486L,7404885469298688L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,3182759744900142L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L),
  "ED":(
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    2901276178251947L,2573484274221227L,2897505196966060L,2573484274221102L,2897488017096746L,2573484274221100L,2573484274221098L,2573484274221130L,
    2901276178251947L,2573484274221227L,2897436477489324L,2573484274221102L,4503600701112320L,2573484274221100L,4503600701112320L,2573484274221130L,
    2901276178251947L,2573484274221227L,2897505196966060L,2573484274221102L,4503600701112320L,4503600701112320L,2573484274221098L,2898527399182410L,
    2901276178251947L,2573484274221227L,2897436477489324L,2573484274221102L,4503600701112320L,4503600701112320L,2573484274221098L,2898527399182410L,
    2901276178251947L,2573484274221227L,2897505196966060L,2573484274221102L,4503600701112320L,4503600701112320L,4503600701112320L,2901276178252333L,
    2901276178251947L,2573484274221227L,2897436477489324L,2573484274221102L,4503600701112320L,4503600701112320L,4503600701112320L,2901276178252333L,
    7404875805622443L,7077084975333376L,2897505196966060L,2573484274221102L,4503600701112320L,4503600701112320L,4503600701112320L,0L,
    2901276178251947L,2573484274221227L,2897436477489324L,2573484274221102L,4503600701112320L,4503600701112320L,4503600701112320L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    2581868050383916L,2894198072149036L,2252083281527372L,2252083281527372L,0L,0L,0L,0L,
    2581868050383916L,2894198072149036L,2252083281527372L,2252083281527372L,0L,0L,0L,0L,
    2583517352825901L,2894198107149357L,2392820789154381L,2392820789154381L,0L,0L,0L,0L,
    2583517352825901L,2894198107149357L,2392820789154381L,2392820789154381L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L),
  "FD":(
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2578028349620396L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2578028349620396L,0L,0L,0L,0L,0L,0L,
    0L,2573484274221100L,2573484274221102L,2573484274221162L,4503600701112320L,4503600701112320L,7077084975333376L,0L,
    0L,2578028349620396L,2573484274221102L,2573484274221162L,4503600701112320L,4503600701112320L,7077084975333376L,0L,
    0L,0L,0L,0L,2897427887557678L,2897496607034414L,2573484274222125L,0L,
    0L,2578028349620396L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274222125L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274222125L,7077084975333376L,
    2573484274222125L,2573484274222125L,2573484274222125L,2573484274222125L,2573484274222125L,2573484274222125L,0L,2573484274222125L,
    0L,0L,0L,0L,7077084975333376L,7077084975333376L,2573484274222125L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897436477490221L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897436477490221L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897505196966957L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897505196966957L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2905691404633133L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2901293358122029L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2901293358122029L,0L,
    0L,0L,0L,0L,4503600701112320L,4503600701112320L,2897505196966957L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2573484274221100L,0L,2573484274237998L,0L,2573484274221132L,0L,0L,
    0L,2573488569188394L,0L,0L,0L,0L,0L,0L,
    0L,0L,0L,0L,0L,0L,0L,0L,
    0L,2573484274221162L,0L,0L,0L,0L,0L,0L),
  "FDCB":(
    7404885469298688L,7404885469298688L,7404885469298688L,7404885469298688L,7404885469298688L,7404885469298688L,2901284768189486L,7404885469298688L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2901284768189486L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,3182759744900142L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2339975492275245L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,4503600701112320L,2573484274224174L,4503600701112320L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L,
    7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,7077084975333376L,2573484274224174L,7077084975333376L)
}

SPECTRUM_COMMANDS=(
    "SPECTRUM","PLAY","RND","INKEY$","PI","FN","POINT","SCREEN$",
    "ATTR","AT","TAB","VAL$","CODE","VAL","LEN","SIN","COS","TAN","ASN","ACS",
    "ATN","LN","EXP","INT","SQR","SGN","ABS","PEEK","IN","USR","STR$","CHR$","NOT",
    "BIN","OR","AND","<=",">=","<>","LINE","THEN","TO","STEP","DEF FN","CAT",
    "FORMAT","MOVE","ERASE","OPEN #","CLOSE #","MERGE","VERIFY","BEEP","CIRCLE",
    "INK","PAPER","FLASH","BRIGHT","INVERSE","OVER","OUT","LPRINT","LLIST","STOP",
    "READ","DATA","RESTORE","NEW","BORDER","CONTINUE","DIM","REM","FOR","GO TO",
    "GO SUB","INPUT","LOAD","LIST","LET","PAUSE","NEXT","POKE","PRINT","PLOT",
    "RUN","SAVE","RANDOMIZE","IF","CLS","DRAW","CLEAR","RETURN","COPY",
    "DEFFN","OPEN#","CLOSE#","GOTO","GOSUB")

def convert_program_to_text(data,iAutostart=0,ivariableOffset=-1):
    """
    This function returns a string representation of the list or byte string supplied of a basic program.
    Due to the way program data was stored, it is possible that non-printable characters were in the line.
    In this case these characters are represented by ^ followed by a 2 digit hexadecimal representation of the character.
    Also floating point numbers are stored after the visible digits. Sometimes for space reasons or to hide the true
    numbers, these did not match up. If The true floating point representation of a number differs from the visible
    one, then the true value is displayed in brackets after the visible number.
   
    data is list or byte string of the data of the program. The program is assumed to begin at he start of the array to the end of the array.
    iAutostart is the line number where the program auto starts (or less than 1 if no autostart).
    ivariableOffset is the offset from the start of the array to where variables are stored.
    """
    
    if(ivariableOffset==-1):
        ivariableOffset=len(data)
    
    #convert data from string to list of numbers if needed
    if(isinstance(data,str)):
        data=[ord(x) for x in data]
        
    text=''
    
    if(iAutostart>=0):
        text="Autostart at line:%i\n" % iAutostart
        
    i=0

    #move through program listing lines
    while(i<ivariableOffset):
        #get line number
        iLineNumber=data[i+1]+256*data[i] #line number is high byte first
        i+=2
        if(iLineNumber>9999):
            raise SpectrumTranslateException("Line number cannot exceed 9999")
            
        text+="%i " % iLineNumber
      
        #get line length
        iLineLen=data[i]+256*data[i+1]
        i+=2
      
        sNumber=''
        bInQuotes=False
        bPostREM=False
        bPostDEF=False
        Lastchar=' '
        
        #now move through line
        l=0
        while(l<iLineLen):
            #get next line entry character
            k=data[i]
            i+=1
          
            #if we're in a REM statement display characters. ignore last character as should be new line character
            if(bPostREM and l<iLineLen-1):
                text+=get_spectrum_char(k)
                l+=1
                continue
          
            #have we reached end of number without hitting number definition?
            if(len(sNumber)>0 and       #are we in a number?
               k!=0x0E and              #and not hitting a hidden number definition
              not(                      #and not an extension of the number
                (k>=0x30 and k<=0x39 and not ' ' in sNumber) or #have 0-9
                k=='E' or k=='e' or     #an exponent symbol
                ((k=='+' or k=='-') and (sNumber[-1]=='E' or sNumber[-1]=='e') ) or #a plus of minus after an exponent symbol
                k==32                   #hit a space
               )
              ):
                #if so exit number gathering routine without gathering number definition
                text+=sNumber
                sNumber=''

            #are we entering/leaving a quote
            if(k=='"'):
                bInQuotes=not bInQuotes
                
            #are we entering or definately leaving a DEF
            if(k==')'):
                bPostDEF=False
                
            if(k==206):
                bPostDEF=True
          
            #deal with non-printable characters, and user-defined characters
            if(k<32 or (k>127 and k<163)):
                if(k==13): #end of line
                    #if still characters hidden after end-of line char then print them
                    if(l!=iLineLen-1):
                        while(l<iLineLen):
                            text+='^%02X' % data[i]
                            i+=1
                            l+=1
                    text+="\n"
                    
                elif(k==14): #number definition
                    #if not enough bytes before end of line or program then we have a problem
                    if(l+5>=iLineLen or i+5>=len(data)):
                        raise SpectrumTranslateException("Error with number format")
                        
                    sn=spectrumnumber.SpectrumNumber(data[i:i+5])
                    i+=5
                    l+=5
                    #ignore what happens after def
                    if(bPostDEF):
                        sNumber=''

                    #output displayed number
                    else:                  
                        text+=sNumber
                        #check if displayed number same as hidden one, and if not also display real number
                        #can cause exceptions so catch them, although is very unlikely
                        #trying to get value of empty string however will cause exception so test for this case & handle it first
                        if(len(sNumber)==0):
                            text+="(%s)" % str(sn)
                        else:
                            try:
                                if(sn!=sNumber):
                                    text+="(%s)" % str(sn)
                            except:
                                text+="(real value unclear)"

                        sNumber=''
                    
                #deal with commands like INK, PAPER etc that have a single byte argument                
                elif((k>=16 and k<=21) or k==23):
                    text+="^%02X^%02X" % (k,data[i])
                    i+=1
                    l+=1

                #deal with AT with x & y coordinates after
                elif(k==22):
                    text+="^%02X^%02X^%02X" % (k,data[i],data[i+1])
                    i+=2
                    l+=2

                else:
                    text+="^%02X" % k
                    i+=1
                    l+=1

            #see if is valid number digit. If so store it in numberbuffer
            if(not bInQuotes and not bPostREM and (
               (k>=0x30 and k<=0x39) or
               k=='.' or
               ((k=='E' or k=='e') and len(sNumber)>0) or
               ((k=='-' or k=='+') and len(sNumber)>0 and (sNumber[-1]=='E' or sNumber[-1]=='e'))
               )):
                sNumber+=chr(k)
                Lastchar=chr(k)
                l+=1
                continue

            #printable characters
            if(k>31 and k<128):
                text+=get_spectrum_char(k)
                
            #check for commands
            if(k>162):
                if(k==234):
                    bPostREM=True
                    
                if(Lastchar!=' ' and not bInQuotes):
                    text+=' '

                text+=SPECTRUM_COMMANDS[k-163]+" "
                k=ord(' ')

            Lastchar=chr(k)
            #exit if hit end of line
            if(k==13):
                break
            
            l+=1

        #see if hit end of program marker
        if(k==128):
            break;
            
    #end program part of code

    #do variables
    if(i<len(data)):
        text+="\n\nVariables:\n"

    while(i<len(data)):
        #get indicator of type of variable
        k=(data[i]>>5)&0x7
      
        VarName=get_spectrum_char((data[i]&0x1F)+0x60)
        
        #number who's name is one letter only
        if(k==3):
            text+=VarName+"="
            text+=_sn_to_string(data[i+1:i+6],"unable to extract number")
            text+="\n"
            i+=6

        #number who's name is greater than 1 letter
        elif(k==5):
            text+=VarName
            i+=1
            
            while(True):
                text+=get_spectrum_char(data[i]&0x7F)
                if(data[i]>127):
                    break
                    
                i+=1

            i+=1
            text+="="+_sn_to_string(data[i:i+5],"unable to extract number")
            text+="\n"
            i+=5

        #array of numbers
        elif(k==4):
            text+=VarName
            i+=1

            #for each dimension, print its length            
            for x in range(data[i+2]):
                text+="[%i]" % (data[i+3+x+x]+256*data[i+4+x+x])

            text+="="+convert_array_to_text(data[i+2:],128)+"\n"
            i+=2+data[i]+256*data[i+1]

        #for next loop control
        elif(k==7):
            try:
                text+="FOR...NEXT, %s Value=%s Limit=%s Step=%s" % (VarName,_sn_to_string(data[i+1:i+6]),_sn_to_string(data[i+6:i+11]),_sn_to_string(data[i+11:i+16]))
                text+=" Loop back to line=%i, statement=%i\n" % (data[i+16]+256*data[i+17],data[i+18])
            except:
                text+="Unable to extract FOR...NEXT variable VarName"

            i+=19

        #string
        elif(k==2):
            strlen=data[i+1]+256*data[i+2]
            text+=VarName+"$=\""+get_spectrum_string(data[i+3:i+3+strlen])+"\"\n"
            i+=strlen+3

        #array of characters
        elif(k==6):
            text+=VarName+"$"
            i+=1

            #for each dimension, print it's length            
            for x in range(data[i+2]):
                text+="[%i]" % (data[i+3+x*2]+256*data[i+4+x*2])

            text+="="+convert_array_to_text(data[i+2:],192)+"\n"
            i+=2+data[i]+256*data[i+1]

        else:
            raise SpectrumTranslateException("Unrecognised variable type")

    return text


def get_array_depth(data,descriptor):
    """
    This method works out how many dimensions there are in a spectrum file array.
    data is the spectrum file array data as a byte array string or list.
    descriptor is the file descriptor for the file array.
        The lower 6 bits specify the array name (a single character). The top 2 specify the array type.
        You don't have to single out these bits as this method will only consider bits 6 and 7. The
        top 2 bits are 128 for a number array, 192 for a character array, and 64 for a string array.
    Returns the number of dimensions in the array, or -1 if not a recognised format.
    
    NB strings are an array of characters and thus array such as String[] would have depth of 2: array of array of characters.
    """
    
    #number array or character array
    if((descriptor&192)==128 or (descriptor&192)==192):
        #deal with string argument
        if(isinstance(data,str)):
            return ord(data[0])

        return data[0]
    
    #string
    if((descriptor&192)==64):
        #always unidimensional
        return 1

    return -1


def convert_array_to_text(data,descriptor):
    """
    This method converts a spectrum array (number, character, or string) to text.
    the elements returned are seperated by commas, and the individual dimensions are seperated by curly brackets.
   
    data is the spectrum file array data supplied as a byte string or list.
    descriptor is the file descriptor for the file array.
        The lower 6 bits specify the array name (a single character). The top 2 specify the array type.
        You don't have to single out these bits as this method will only consider bits 6 and 7. The
        top 2 bits are 128 for a number array, 192 for a character array, and 64 for a string array.
    """
    
    #convert data from string to list of numbers if needed
    if(isinstance(data,str)):
        data=[ord(x) for x in data]

    sIndent="  "

    #number array
    if(descriptor&192==128):
        #get dimension lengths
        dim_lengths=[data[x]+256*data[x+1] for x in range(1,data[0]*2,2)]
        #o is current offset. Set to past dimensions details pointing at first element
        o=len(dim_lengths)*2+1
        #pointer to where we are in each dimension
        dim_pos=[0 for x in dim_lengths]
        #which dim are we in
        i=0
        
        text="{\n"
        
        #loop until have gone through all dims
        while(dim_pos[0]<dim_lengths[0]):
            text+=sIndent
            #if at top level loop through elements
            if(i==len(dim_lengths)-1):
                while(dim_pos[i]<dim_lengths[i]):
                    #get number
                    sn=spectrumnumber.SpectrumNumber(data[o:o+5])

                    #convert to string: can cause exceptions
                    try:
                        text+=str(sn)
                    except:
                        text+="real value unclear"

                    text+=dim_pos[i]==dim_lengths[i]-1 and "\n" or ","
                    o+=5
                    dim_pos[i]+=1

                sIndent=sIndent[:-2]
                text+=sIndent

            #if need to go down dimension
            if(dim_pos[i]==dim_lengths[i]):
                i-=1
                if(i>=0):
                    dim_pos[i]+=1
                    text+="}"+(dim_pos[i]==dim_lengths[i] and "" or ",")+"\n"

                if(i>=0 and dim_pos[i]==dim_lengths[i]):
                    sIndent=sIndent[:-2]

            #entering a new dimension
            else:
                i+=1
                dim_pos[i]=0
                sIndent+="  "
                text+="{\n"

        text+="}\n"
        
        return text

    #character array
    if(descriptor&192==192):
        #get dimension lengths
        dim_lengths=[data[x]+256*data[x+1] for x in range(1,data[0]*2,2)]
        #o is current offset. Set to past dimensions details pointing at first element
        o=len(dim_lengths)*2+1
        #pointer to where we are in each dimension
        dim_pos=[0 for x in dim_lengths]
        #which dim are we in
        i=0

        text="{\n"
        
        #loop until have gone through all dims
        while(dim_pos[0]<dim_lengths[0]):
            if(i==len(dim_lengths)-2):
                while(dim_pos[i]<dim_lengths[i]):
                    text+=sIndent
                    text+="\""
                    text+=get_spectrum_string(data[o:o+dim_lengths[i+1]])
                    text+=dim_pos[i]==dim_lengths[i]-1 and "\"\n" or "\",\n"
                    o+=dim_lengths[i+1]
                    dim_pos[i]+=1

                sIndent=sIndent[:-2]
                text+=sIndent

            if(dim_pos[i]==dim_lengths[i]):
                i-=1
                if(i>=0):
                    dim_pos[i]+=1
                    text+="}"+(dim_pos[i]==dim_lengths[i] and "" or ",")+"\n"

                if(i>0 and dim_pos[i]==dim_lengths[i]):
                    sIndent=sIndent[:-2]

            #entering a new dimension
            else:
                i+=1
                dim_pos[i]=0
                text+=sIndent
                sIndent+="  "
                text+="{\n"

        text+="}"
        
        return text
        
    #string
    if(descriptor&192==64):
        return '"'+get_spectrum_string(data[2:data[0]+256*data[1]])+'"'

    return None

#function to transfer number to string and handle exceptions
def _sn_to_string(data,message=-1):
    #get number
    sn=spectrumnumber.SpectrumNumber(data)

    #convert to string: can cause exceptions
    try:
        return str(sn)
    except:
        if(message==-1):
            raise
        return message


#NB some spectrum characters are command words
#also doesn't use standard ASCII
def get_spectrum_char(c):
    """
    This method converts the 8 bit integer value of a spectrum character to a string representation of the spectrum character.
    The lower part is mostly in line with ASCII standard with a couple of exceptions: character decimal 96 is the
    pound sign, character decimal 94 is an up arrow (there is no ^ in the spectrum character set), and character
    decimal 127 is a copyright symbol. characters decimal 164 up to 255 (162 to 255 in the 128K versions) are not
    simple characters but are the names of the spectrum commands with a space after them. From decimal 144 to 163
    (or 161 on 128K machines) were used for the user defined characters. This function will return the spectrum
    character of the character, the command, or the value in 2 digit hexadecimal preceded by a '^'.
   
    Returns the Spectrum string representation of the byte supplied
    """

    #convert to int if needed
    if(isinstance(c,(str,unicode))):
        c=ord(c[0])&0xFF

    if(c==127):
        return u"\u00A9"
    if(c==96):
        return u"\u00A3"
    if(c==94):
        return u"\u2191"
    if(c<32 or c>127):
        return "^%02X" % (c)

    return chr(c)

#NB some spectrum characters are command words
#also doesn't use standard ASCII
def get_spectrum_string(s):
    """
    This method converts a byte sting of 8 bit integer values to a string representation of the spectrum character.
    The lower part is mostly in line with ASCII standard with a couple of exceptions: character decimal 96 is the
    pound sign, character decimal 94 is an up arrow (there is no ^ in the spectrum character set), and character
    decimal 127 is a copyright symbol. characters decimal 164 up to 255 (162 to 255 in the 128K versions) are not
    simple characters but are the names of the spectrum commands with a space after them. From decimal 144 to 163
    (or 161 on 128K machines) were used for the user defined characters. This function will return the spectrum
    character of the character, the command, or the value in 2 digit hexadecimal preceded by a '^'.
   
    Returns the Spectrum string representation of the bytes supplied
    """

    if(isinstance(s,list)):
        s=[chr(x) for x in s]
        
    return ''.join([get_spectrum_char(c) for c in s])


#array to map from colours to colour data so that bright black & not bright black both map to 0x000000
_colour_map=(0,1,2,3,4,5,6,7,0,9,10,11,12,13,14,15)
#array of ZX spectrum colours
_zx_to_RGB=(
    0x000000,0x0000CD,0xCD0000,0xCD00CD,0x00CD00,0x00CDCD,0xCDCD00,0xCDCDCD,
    0x000000,0x0000FF,0xFF0000,0xFF00FF,0x00FF00,0x00FFFF,0xFFFF00,0xFFFFFF)

def get_GIF_from_screen(data,delay=320):
    """
    This method extracts an Image from spectrum screen format data. It outputs it as an array of byte in
    the format of a GIF file. This can either be saved to a file as a GIF image or used as the argument
    for a PIL (Python Image Library) object wia stringIO for example. This method returns an animated GIF if
    the flash attribute is used. The delay value specifies the length of time for each version of the screen
    to be displayed with the flash blocks in either state. On the origional spectrum this was 16 frames which
    at 50Hz for screen refresh equates to 320 milliseconds. If there is no flash being used then it returns a
    normal static GIF image.
   
    Data is the data for the spectrum screen. It can be a list, or byte string array.
    
    Delay is the delay between flashing images in milliseconds if the image has flashing colours. If you don't
    want a flashing image then pass -1 for delay and the method will return a static GIF image of the screen
    effectively with all flash attributes turned off.
    
    This returns a byte string which holds the screen image in GIF format. It will be static or 2 frame
    animated depending on whether there are flashing colours and if you want them. You can simply save the byte
    array to a file for it to be used as a GIF image, or pass it on to other functions. It returns None if the
    method encounters any problems.
    """
    
    #if not enough data for image supplied
    if(len(data)<6912):
        return None

    #convert data to list of ints if needed
    if(isinstance(data,str)):
        data=[ord(x[0]) for x in data]

    #is there a flash atribute in the screen
    bFlash=False
    
    #is there a flash flag set in the colour area?
    i=0x1800
    while(i<0x1B00):
        if(data[i]>=0x80):
            bFlash=True
            break
            
        i+=1

    #create object to encode gif data
    ges=_gif_encoder_stream(data)

    #put headder
    ges.PutString("GIF89a")
    #width
    ges.PutWord(256)
    #height
    ges.PutWord(192)
    #bits per pixel+other flags
    ges.PutByte(243)
    ges.PutByte(0)
    ges.PutByte(0)

    #output colour map
    for i in _colour_map:
        ges.PutByte((_zx_to_RGB[i]>>16)&0XFF)
        ges.PutByte((_zx_to_RGB[i]>>8)&0XFF)
        ges.PutByte(_zx_to_RGB[i]&0XFF)

    #put delay if have flash & want image (delay!=-1)
    if(bFlash and delay!=-1):
        ges.PutByte(0x21)  #extension introducer
        ges.PutByte(0xff)  #app extension label
        ges.PutByte(11)    #block size
        ges.PutString("NETSCAPE2.0")   #app id + auth code
        ges.PutByte(3)     #sub-block size
        ges.PutByte(1)     #loop sub-block id
        ges.PutWord(0)     #loop count (0=repeat forever)
        ges.PutByte(0)     #block terminator

    #output Image
    ges.PutImageAsGif(bFlash,delay,True)
    #output 2nd image if apropriate
    if(bFlash and delay!=-1):
        ges.PutImageAsGif(bFlash,delay,False)

    #gif trailer
    ges.PutByte(0x3b)

    return ''.join([chr(c) for c in ges.out])

#private class to encode gif data
class _gif_encoder_stream():
    output_masks=(0x0000,0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,
                  0x01FF,0x03FF,0x07FF,0x0FFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF)
                  
    MaxOutputCode=0xFFF

    def __init__(self,data):
        #remember screen we're encodeing
        self.data=data
        self.out=[]
        
    def PutImageAsGif(self,bFlash,delay,bFirst):
        """this method outputs an image to the supplied stream."""

        #output graphic control extension
        self.PutByte(0x21)  #extension introducer
        self.PutByte(0xf9)  #GCE label
        self.PutByte(4)     #data block size
        self.PutByte(0)     #no transparency
        self.PutWord(0 if (delay==-1) else delay/10) #delay in 1/100 of seconds
        self.PutByte(0)     #transparent color index
        self.PutByte(0)     #block terminator
    
        #output image desriptor
        self.PutByte(0x2c)  #image separator
        self.PutWord(0)     #image position x,y = 0,0
        self.PutWord(0)
        self.PutWord(256)   #image size
        self.PutWord(192)
        #packed fields
        self.PutByte(0 if bFirst else 0x83) #no Local Colour Table if first frame, othewise 4 bit LCT
    
        #output colour map if not first
        if(not bFirst):
            for i in _colour_map:
                self.PutByte((_zx_to_RGB[i]>>16)&0XFF)
                self.PutByte((_zx_to_RGB[i]>>8)&0XFF)
                self.PutByte(_zx_to_RGB[i]&0XFF)
    
        #record initial code bit size
        self.PutByte(4)
    
        #output compressed image
        #add 1 to code size to accomodate control codes
        self.compress(not bFirst,5)
    
        #write block terminator
        self.PutByte(0)

    def compress(self,bFlash,initialDataBitSize):
        """compress image to output stream using LZW compression"""
        
        #initiate bit cue & byte cue
        self.cue=[0]*255
        self.output_cue=0
        self.output_cueBits=0
        self.output_dataSize=initialDataBitSize
        self.output_cuePointer=0
        
        #initiate compression stuff
        code_tableReset=1<<(initialDataBitSize-1)
        code_EOF=code_tableReset+1
        incBitsAt=(1<<initialDataBitSize)+1
        compressionArray=[0]*(self.MaxOutputCode+1)
        compressionArraySize=code_EOF+1
        for i in range(code_EOF):
            compressionArray[i]=i|0xFFFF000

        #start by issuing table reset code
        self.OutputBits(code_tableReset)
        #set no previous sequence
        CompressionValue=0
        #get first pixel
        OldCompressionValue=self.GetPixelColour(0,0,bFlash)
        #set where to start looking for sequence to see if we've encountered it before
        #Code_EOF+1 will be first code not used by control code or basic colours
        SearchPoint=code_EOF+1
    
        #now go through image compressing pixels
        #start with x=1 on first line of y
        startx=1
        for y in range(192):
            for x in range(startx,256):
                #calculate internal code for sequence+next pixel
                #_logString("compressionval:("+str(OldCompressionValue)+"->"+str((OldCompressionValue<<12)|self.GetPixelColour(x,y,bFlash))+"\n")
                CompressionValue=(OldCompressionValue<<12)|self.GetPixelColour(x,y,bFlash)
                #search list of sequences to see if current sequence already exists
                i=SearchPoint
                while(i<compressionArraySize):
                    if(compressionArray[i]==CompressionValue):
                        break
                    
                    i+=1
               
                #_logString("compressionarray:"+str(i)+" out of "+str(compressionArraySize)+"\n")
                        
                #if sequence already exists, then remember loop back to look for longer sequence
                if(i<compressionArraySize):
                    #longer matching sequence will come later in sequence table if exists so no point searching
                    #first part of sequence table again. Setting Search Point avoids this.
                    OldCompressionValue=i
                    SearchPoint=i
                    continue

                #have found a new pixel sequence, so add it to the list of sequences
                compressionArray[compressionArraySize]=CompressionValue
                compressionArraySize+=1
                #reset where to search sequence table from as will be starting a new sequence now
                SearchPoint=code_EOF+1
                #output existing sequence
                self.OutputBits(OldCompressionValue)
                #start new sequence with first pixel that doesn't match existing pixel sequence
                OldCompressionValue=CompressionValue&0xFFF
                #check if have reached maximum number of sequences possible
                if(compressionArraySize==self.MaxOutputCode):
                    #if so then output code to note table reseet
                    self.OutputBits(code_tableReset)
                    #reset sequence table
                    compressionArraySize=code_EOF+1
                    #reset output code bit size as will be shorter code for sequences
                    self.output_dataSize=initialDataBitSize
                    #work out when will need to increase output code bit size
                    incBitsAt=(1<<initialDataBitSize)+1

                #if we have to have more bits in output code to hold sequence code then increment output bits
                #and make note of when to increase the number of output bits again
                if(compressionArraySize==incBitsAt):
                    self.output_dataSize+=1
                    incBitsAt=(1<<self.output_dataSize)+1

            startx=0

        #finished going through image.
        #There will be sequence still left in output buffer so output this
        self.OutputBits(OldCompressionValue&0xFFF)
        #output end of file code
        self.OutputBits(code_EOF);
        #if there are bits waiting to be written int the output cue write them now
        while(self.output_cueBits>0):
            self.cue[self.output_cuePointer]=self.output_cue&0xFF
            self.output_cuePointer+=1
            #if cue full, then output it
            if(self.output_cuePointer==255):
                self.out+=[0xFF]
                self.out+=cue
                self.output_cuePointer=0

            self.output_cue>>=8
            self.output_cueBits-=8

        #if still bits in cue
        if(self.output_cuePointer>0):
            self.out+=[self.output_cuePointer]
            self.out+=self.cue[0:self.output_cuePointer]

    def GetPixelColour(self,x,y,bFlash):
        """get colour 1-15 of specified pixel, inverted if is flashing"""
        colour=self.data[0x1800+((y>>3)<<5)+(x>>3)]
        fg=_colour_map[(colour&7)+((colour>>3)&8)]
        bg=_colour_map[(colour>>3)&15];

        #swap foreground & background if flash & second image
        if(colour>=128 and bFlash):
            fg,bg=bg,fg

        pixels=self.data[((y>>6)<<11)+((y&7)<<8)+(((y>>3)&7)<<5)+(x>>3)]

        #_logString("getpixel:("+str(x)+","+str(y)+")="+str(fg if ((pixels>>(7-(x&7)))&1)==1 else bg)+"\n")
        return fg if ((pixels>>(7-(x&7)))&1)==1 else bg

    #output bits to bit output cue
    def OutputBits(self,bits):
        #_logString("Output:"+str(bits)+"("+str(self.output_dataSize)+")\n")
        #tidy bitcue in case loose bits attached (not sure if this is strictly needed but is safe)
        self.output_cue&=self.output_masks[self.output_cueBits]
        #add new bits to bitcue
        if(self.output_cueBits>0):
            self.output_cue|=bits<<self.output_cueBits
            
        #no bitcue so set bitcue as bits to add
        else:
            self.output_cue=bits
    
        #update how many bits in bitcue
        self.output_cueBits+=self.output_dataSize
        #if more than 8 bits in bitcue, output a byte at a time
        while(self.output_cueBits>=8):
            #add from bitcue to byte cue
            self.cue[self.output_cuePointer]=self.output_cue&0xFF
            #increment number of bytes in byte cue
            self.output_cuePointer+=1
            #if buffer full, output them to stream
            if(self.output_cuePointer==255):
                #block headder
                self.out+=[0xFF]
                #output cue
                self.out+=self.cue
                #reset byte cue pointer
                self.output_cuePointer=0

            #8 bits have been moved from bit cue to byte cue. Update bitcue & bitcue length
            self.output_cue>>=8
            self.output_cueBits-=8

    #output 2 byte word
    def PutWord(self,w):
        self.out+=[w&0xff,(w>>8)&0xff]

    #output string
    def PutString(self,s):
        self.out+=[ord(x) for x in s]

    #output single byte
    def PutByte(self,b):
        self.out+=[b]

def get_RGB_from_screen(data):
    """
    This function extracts an Image from spectrum screen format data.
    
    data is the spectrum screen data supplied as a byte array string or list.
    This returns a 2 element list. Because of flashing colours in the spectrum, there are
    efectively 2 images: one for each of the 2 flashing colour states. Image 0 is the normal Image. If there are
    no flashing colours in the image, then the second element in the returned list is None, otherwise it is the
    image with the flashing colours inverted.
    The returned images are in RGB format ints (bits 16-23 are red, 8-15 are green, and 0-7 are Blue), and are
    an array for each pixel starting at x=0,y=0, then x=1,y=0, x=2,y=0 etc. The images are 256 pixels wide, and
    192 pixels high, so any pixel can be extracted with by useing image[x+y*256].
    """
    
    #calculate number of images needed: is there a flash flag set in the colour area?
    bFlash=False
    i=0x1800
    while(i<0x1B00):
        if(data[i]>=0x80):
            bFlash=True
            break
            
        i+=1

    image1=[]
    for y in range(192):
        #get pixel address for start of row
        p=((y>>6)<<11)+((y&7)<<8)+(((y>>3)&7)<<5)
        #get colour address for start of row
        c=0x1800+((y>>3)<<5)
        for x in range(0,256,8):
            #work out foreground & backgrounc colour
            i=data[c]
            fg=_zx_to_RGB[(i&7)+((i>>3)&8)]
            bg=_zx_to_RGB[(i>>3)&15]
            #get pixel data for 8 pixel row
            i=data[p]
            image1.append(bg if (i&128)==0 else fg)
            image1.append(bg if (i&64)==0 else fg)
            image1.append(bg if (i&32)==0 else fg)
            image1.append(bg if (i&16)==0 else fg)
            image1.append(bg if (i&8)==0 else fg)
            image1.append(bg if (i&4)==0 else fg)
            image1.append(bg if (i&2)==0 else fg)
            image1.append(bg if (i&1)==0 else fg)
            c+=1
            p+=1

    #now deal with flash image if needed
    if(bFlash==True):
        image2=[]
        for y in range(192):
            #get pixel address for start of row
            p=((y>>6)<<11)+((y&7)<<8)+(((y>>3)&7)<<5)
            #get colour address for start of row
            c=0x1800+((y>>3)<<5)
            for x in range(0,256,8):
                #work out foreground & backgrounc colour
                i=data[c]
                fg=_zx_to_RGB[(i&7)+((i>>3)&8)]
                bg=_zx_to_RGB[(i>>3)&15]
                if(i>=128): #swap foreground & background as flashing
                    fg,bg=bg,fg
                    
                #get pixel data for 8 pixel row
                i=data[p]
                image2.append(bg if (i&128)==0 else fg)
                image2.append(bg if (i&64)==0 else fg)
                image2.append(bg if (i&32)==0 else fg)
                image2.append(bg if (i&16)==0 else fg)
                image2.append(bg if (i&8)==0 else fg)
                image2.append(bg if (i&4)==0 else fg)
                image2.append(bg if (i&2)==0 else fg)
                image2.append(bg if (i&1)==0 else fg)
                c+=1
                p+=1

        #return 2 images
        return [image1,image2]

    #return only one image as no flash
    return [image1,None]

#todo implement other formats of snapshot
def snap_to_SNA(data,AF,BC,DE,HL,AF_,BC_,DE_,HL_,I,R,IX,IY,SP,IFF2,IM,border,port7FFD,bank):
    """Function to convert data of +D/Disciple format snapshot to .SNA format byte string that can be saved.
    AF,BC,DE,HL,I,R,IX,IY,and SP are the Z80 registers of the same name. AF_, BC_, DE_, and HL_ are the 
    Z80 alternate registers AF', BC', DE', and HL'. IFF2 is interupt state, IM is the interupt mode,
    border is the border colour, port7FFD and bank are 128K details to do with which page is in memory and sound.
    """
    
    #first check have valid data
    #return if not 48k or 128K
    if(len(data)!=49152 and len(data)!=131072):
        return None

    #convert data to list of ints if needed
    if(isinstance(data,str)):
        data=[ord(x[0]) for x in data]

    #output common headder registers
    out=[I&0xFF,HL_&0xFF,(HL_>>8)&0xFF,DE_&0xFF,(DE_>>8)&0xFF,BC_&0xFF,(BC_>>8)&0xFF,AF_&0xFF,(AF_>>8)&0xFF]
    out+=[HL&0xFF,(HL>>8)&0xFF,DE&0xFF,(DE>>8)&0xFF,BC&0xFF,(BC>>8)&0xFF,IY&0xFF,(IY>>8)&0xFF]
    out+=[IX&0xFF,(IX>>8)&0xFF,4 if IFF2 else 0,R&0xFF,AF&0xFF,(AF>>8)&0xFF,SP&0xFF,(SP>>8)&0xFF]
    out+=[IM&0xFF,border&7]

    #if 48K then add memory dump & return
    if(len(data)==49152):
        #Program Counter needs to be on the stack so can't simply dump memory contents
        #calculate where SP offset is in data
        SPoffset=SP-0x4000
        #first save off the data before the stack pointer
        out+=data[0:SPoffset]
        #output program counter
        out+=[PC&0xFF,(PC>>8)&0xFF]
        #save off data after stack pointer+2
        #+2 to skip 2 bytes taken up by PC
        out+=data[SPoffset+2:]
        #return snapshot as byte array string
        return ''.join([chr(c) for c in out])

    #should be 128K snapshots only now

    #output ram bank 5
    out+=data[5*16384:6*16384]
    #output ram bank 2
    out+=data[2*16384:3*16384]
    #check if valid bank
    if(bank<0 or bank>7):
        return None
        
    #output currently paged ram bank
    out+=data[bank*16384:(bank+1)*16384]

    #output program counter
    out+=[PC&0xFF,(PC>>8)&0xFF]
    #output port 7FFD setting
    out+=[port7FFD&0xFF]
    #output empty byte that no-one seems to know what it's for
    out+=[0]

    #now output remaining RAM banks
    for i in range(8):
        #check if RAM bank already output
        if(i==2 or i==5 or i==bank):
            continue
            
        #otherwise output RAM bank
        out+=data[i*16384:(i+1)*16384]

    #return snapshot as byte array string
    return ''.join([chr(c) for c in out])

def disassemble(data,offset,origin,length,SpecialInstructions=None):
    """
    This method will disassemble a byte string or list holding Z80 code.
    You can specify instructions to alter the disassembled output.
   
    data is a byte string or list holding the data to disassemble.
    offset is how far into the array to start disassembling.
    origin is the address of the first byte in the byte array.
    length is how many bytes to disassemble
    SpecialInstructions is a list of DisassembleInstruction instructing things like output format, and data blocks. Should be None if no array to pass.
    
    Returns a String representation of the data.
    """

    #nested functions
    
    #get string for used flags
    def getFlagChanges(instructionData):
        #do we have flag data?
        if(((instructionData>>51)&1)==0):
            #if not return None
            return None
        
        #holds flag indicators
        FlagStates=("?","-","+","0","1","P","V")
        
        s="S"+FlagStates[(instructionData>>48)&7]+" Z"+FlagStates[(instructionData>>45)&7]
        s+=" H"+FlagStates[(instructionData>>42)&7]+" PV"+FlagStates[(instructionData>>39)&7]
        s+=" N"+FlagStates[(instructionData>>36)&7]+" C"+FlagStates[(instructionData>>33)&7]
        
        return s

    #extract timing information
    def GetTimingInfo(instructionData):
        #calculate times
        #first clear variables where results will be calculated
        duration=[0,0]
        states=None
        
        #if only overall T length known then extract this now
        if((instructionData&0x40000000L)!=0):
            duration=[instructionData&0x7FFFL,(instructionData>>15)&0x7FFFL]

        #otherwise individual component parts of time known
        else:
            states=[[],[]]
            #get number of T states
            k=instructionData&7
            #offset
            i=3
            while(k>0):
                t=((instructionData>>i)&3)+3
                states[0].append(t)
                duration[0]+=t
                i+=2
                k-=1

            #do alternative length if exists
            k=(instructionData>>15)&7
            i=18
            while(k>0):
                t=((instructionData>>i)&3)+3
                states[1].append(t)
                duration[1]+=t
                i+=2
                k-=1
        
        return duration,states

    #end nested functions

    #holds how long address is in each number format
    FormatAddressLength=(4,5,7,17)
    #holds how long byte is in each number format
    FormatByteLength=(2,3,3,8)
    #holds max length of opcode for each number format
    FormatOpCodeMaxLength=(19,20,21,27)

    maxAddressLength=0;

    #work out where we are
    currentAddress=origin+offset

    #convert data to list of ints if needed
    if(isinstance(data,str)):
        data=[ord(x[0]) for x in data]

    #get list of line numbers that are being referenced
    ReferencedLineNumbers=[currentAddress]

    #set format flags to default
    AddressOutput=0        #0=hex,1=decimal,2=octal,3=binary
    NumberOutput=0         #0=hex,1=decimal,2=octal,3=binary
    CommandOutput=0        #0=hex,1=decimal,2=octal,3=binary
    OutputTStates=0        #0=no, 1=total only, 2=list state times, 3=total & state times
    BreakAfterJumps=1      #0=no empty lines, 1=after absolute jumps/rets, 2=after all rets/jumps
    LineNumberOutput=0     #0=All, 1=None, 2=only referenced lines
    ListEveryXLines=0      #list every X lines regardless of LineNumberOutput
    BreakAfterData=0       #0=empty line after data, 1=no empty line after data
    TreatDataNumbersAsLineReferences=0 #0=track line numbers for display purposes, 1=don't
    DisplayCommandBytes=0  #0=print them, 1=don't
    DisplayComments=0      #0=display them, 1=don't
    SeperatorMode=0        #0=2 spaces, 1=tab
    ShowFlags=0            #0=no, 1=yes
    MarkUndocumenedCommand=0 #0=no, 1=yes
    XMLOutput=0            #0=no, 1=yes
    
    #process special instructions
    DisassembleInstructions=[]
    if(SpecialInstructions!=None and len(SpecialInstructions)>0):
        for di in SpecialInstructions:
            #first see if it's a special format instruction holding formatting info
            if(di.start==0x0000 and di.end==0xFFFF and
               di.instruction==DisassembleInstruction.DisassembleCodes["Custom Format"]):
                #get default dissassembly format settings
                settingstemp=get_custom_format_values(di.data,False)
                AddressOutput=settingstemp["AddressOutput"]
                NumberOutput=settingstemp["NumberOutput"]
                CommandOutput=settingstemp["CommandOutput"]
                OutputTStates=settingstemp["OutputTStates"]
                BreakAfterJumps=settingstemp["BreakAfterJumps"]
                LineNumberOutput=settingstemp["LineNumberOutput"]
                ListEveryXLines=settingstemp["ListEveryXLines"]
                BreakAfterData=settingstemp["BreakAfterData"]
                TreatDataNumbersAsLineReferences=settingstemp["TreatDataNumbersAsLineReferences"]
                DisplayCommandBytes=settingstemp["DisplayCommandBytes"]
                DisplayComments=settingstemp["DisplayComments"]
                SeperatorMode=settingstemp["SeperatorMode"]
                ShowFlags=settingstemp["ShowFlags"]
                MarkUndocumenedCommand=settingstemp["MarkUndocumenedCommand"]
                XMLOutput=settingstemp["XMLOutput"]
                
                continue

            #check if end after end of code, in which case truncate it
            if(di.end>=origin+len(data)):
                di.end=origin+len(data)-1

            #check if start before start of code, in which case truncate it
            if(di.start<origin):
                di.start=origin
                
            #is this a patterndatablock instruction?
            if(di.instruction==DisassembleInstruction.DisassembleCodes["Pattern Data Block"]):
                #get parts of patterndatablock
                TestBlock,PrepBlock,ActionBlock=GetPartsOfPatternDataBlock(di.data)

                #first check is valid test block
                if(TestBlock==None):
                    raise NewSpectrumTranslateException(Vars[0x0A],0,di.data,"patern to search for must be inside brackets")
                    
                #now check is valid preperation block
                if(PrepBlock==None):
                    raise NewSpectrumTranslateException(Vars[0x0A],0,di.data,"preperation block must be inside brackets")
                
                #now should have valid pattern match we can work with

                #setup environment ready to search for matches
                Settings={"DATASTRINGPOS":0,"NUMBERFORMAT":0,"NUMBERSIGNED":0,"NUMBERWORDORDER":0,"DISPLAYEVERYXLINES":1,
                          "ORIGIONALSEPERATOR":SeperatorMode,"SEPERATOR":SeperatorMode,"ORIGIN":origin,
                          "ADDRESSOUTPUT":AddressOutput,"NUMBEROUTPUT":NumberOutput,"COMMANDOUTPUT":CommandOutput,
                          "XMLOutput":XMLOutput}

                Vars=[0,0,0,0,0,0,0,0,0,0,di.start,0,0,di.start,di.end]
              
                #move through area covered by instruction & check for matches
                k=di.start
                while(k<=di.end):
                    Settings["DATASTRINGPOS"]=0
                    Vars[0x00]=k
                    Vars[0x01]=di.end
                    Vars[0x0C]=0
                    Vars[0x0A]=k
                    Vars[0x0D]=k
                    Vars[0x0E]=di.end
                    #test each address
                    if((DisassembleInstruction.ProcessCommandBlock(TestBlock,Vars,Settings,data,None,true,true,None)&1)==1):
                        #have found match
                        Settings["DATASTRINGPOS"]=0
                        Vars[0x00]=k
                        Vars[0x01]=di.end
                        Vars[0x0C]=0
                        Vars[0x0A]=k
                        Vars[0x0D]=k
                        Vars[0x0E]=di.end
                        #now adjust variables as needed
                        DisassembleInstruction.ProcessCommandBlock(PrepBlock,Vars,Settings,data,None,true,false,None)
                        #add datablock
                        DisassembleInstructions+=[DisassembleInstruction(DisassembleInstruction.DisassembleCodes["Data Block"],Vars[0x00],Vars[0x01],ActionBlock)]

                    k+=1

                continue
          
            #check if is reference instruction
            if(di.instruction==DisassembleInstruction.DisassembleCodes["Reference Line"]):
                ReferencedLineNumbers+=[di.start]
                continue
          
            #add instruction to list of stuff to do during disassembly
            DisassembleInstructions+=[di]

        #sort instructions by their start address
        DisassembleInstructions=sorted(DisassembleInstructions)

    #should now be sorted along by start

    #set up format stack to hold current format
    #hold formatting instructions
    s=get_custom_format_string(AddressOutput,NumberOutput,CommandOutput,OutputTStates,BreakAfterJumps,LineNumberOutput,ListEveryXLines,BreakAfterData,TreatDataNumbersAsLineReferences,DisplayCommandBytes,DisplayComments,SeperatorMode,ShowFlags,MarkUndocumenedCommand,XMLOutput);
    Format=[DisassembleInstruction(DisassembleInstruction.DisassembleCodes["Custom Format"],0,65536,s)]
    CurrentFormatEnd=65536  #end after

    #hold data formatting instructions
    nextDataFormatStart=65536  #start after
    nextDataFormatEnd=65536    #end after

    #output start text
    if(XMLOutput==1):
        soutput='<?xml version="1.0" encoding="UTF-8" ?>\n<z80code>\n  <org>'
        soutput+=NumberToString(currentAddress,16,AddressOutput)+"</org>\n"

    else:
        soutput="ORG "+NumberToString(currentAddress,16,AddressOutput)+"\n\n"

    #di is next disassemble instruction
    di=DisassembleInstructions.pop(0) if DisassembleInstructions else None

    #start disassembling
    while(length>0):
        #are we exiting format section?
        if(currentAddress>CurrentFormatEnd):
            #if so recover details of underlying format
            diTemp=Format.pop()
            settingstemp=get_custom_format_values(diTemp.data,False)
            AddressOutput=settingstemp["AddressOutput"]
            NumberOutput=settingstemp["NumberOutput"]
            CommandOutput=settingstemp["CommandOutput"]
            OutputTStates=settingstemp["OutputTStates"]
            BreakAfterJumps=settingstemp["BreakAfterJumps"]
            LineNumberOutput=settingstemp["LineNumberOutput"]
            ListEveryXLines=settingstemp["ListEveryXLines"]
            BreakAfterData=settingstemp["BreakAfterData"]
            TreatDataNumbersAsLineReferences=settingstemp["TreatDataNumbersAsLineReferences"]
            DisplayCommandBytes=settingstemp["DisplayCommandBytes"]
            DisplayComments=settingstemp["DisplayComments"]
            SeperatorMode=settingstemp["SeperatorMode"]
            ShowFlags=settingstemp["ShowFlags"]
            MarkUndocumenedCommand=settingstemp["MarkUndocumenedCommand"]
            XMLOutput=settingstemp["XMLOutput"]
          
            CurrentFormatEnd=diTemp.end
            continue
      
      
        #first check if in data block
        if(di!=None and di.instruction==DisassembleInstruction.DisassembleCodes["Data Block"] and currentAddress>=di.start):
            Settings={"DATASTRINGPOS":0,"NUMBERFORMAT":0,"NUMBERSIGNED":0,"NUMBERWORDORDER":0,"DISPLAYEVERYXLINES":1,
                      "ORIGIONALSEPERATOR":SeperatorMode,"SEPERATOR":SeperatorMode,"ORIGIN":origin,
                      "ADDRESSOUTPUT":AddressOutput,"NUMBEROUTPUT":NumberOutput,"COMMANDOUTPUT":CommandOutput,
                      "XMLOutput":XMLOutput}
            di.end,txt=di.DisassembleDataBlock(Settings,data,ReferencedLineNumbers if (TreatDataNumbersAsLineReferences==0) else None)
            soutput+=txt
          
            #adjust length
            length-=di.end-currentAddress+1
          
            #point to end of data block
            currentAddress=di.end+1
          
            #adjust offset
            offset=currentAddress-origin
          
            #di is now next disassemble instruction
            di=DisassembleInstructions.pop(0) if DisassembleInstructions else None
          
            #put empty line after data
            if(BreakAfterData==0):
                soutput+="\n"
          
            continue
      
        #check formatting command
        if(di!=None and di.is_format_instruction() and currentAddress>=di.start):
            #record current format state in custom, place on stack
            s=get_custom_format_string(AddressOutput,NumberOutput,CommandOutput,OutputTStates,BreakAfterJumps,LineNumberOutput,ListEveryXLines,BreakAfterData,TreatDataNumbersAsLineReferences,DisplayCommandBytes,DisplayComments,SeperatorMode,ShowFlags,MarkUndocumenedCommand,XMLOutput)
            Format+=[DisassembleInstruction(DisassembleInstruction.DisassembleCodes["Custom Format"],currentAddress,CurrentFormatEnd,s)]
          
            #deal with format commands
            if(di.instruction&0xFF00==0x0100): #AddressOutputFormat
                AddressOutput=di.instruction&0x03
                
            elif(di.instruction&0xFF00==0x0200): #NumberOutputFormat
                NumberOutput=di.instruction&0x03
                
            elif(di.instruction&0xFF00==0x0300): #CommandOutputFormat
                CommandOutput=di.instruction&0x03
                
            elif(di.instruction&0xFF00==0x0400): #OutputTStatesFormat
                OutputTStates=di.instruction&0x03
                
            elif(di.instruction&0xFF00==0x0500): #LineAfterJumpOutputFormat
                BreakAfterJumps=di.instruction&0x03
                
            elif(di.instruction&0xFF00==0x0600): #DefaultFormat
                AddressOutput=di.instruction&0x03
                NumberOutput=di.instruction&0x03
                CommandOutput=di.instruction&0x03
                OutputTStates=0
                BreakAfterJumps=1
                LineNumberOutput=0
                ListEveryXLines=0
                BreakAfterData=0
                TreatDataNumbersAsLineReferences=0
                DisplayCommandBytes=0
                DisplayComments=0
                SeperatorMode=0
                ShowFlags=0
                MarkUndocumenedCommand=0
                XMLOutput=0
                
            elif(di.instruction&0xFF00==0x0700): #CustomFormat
                settingstemp=get_custom_format_values(di.data,False)
                AddressOutput=settingstemp["AddressOutput"]
                NumberOutput=settingstemp["NumberOutput"]
                CommandOutput=settingstemp["CommandOutput"]
                OutputTStates=settingstemp["OutputTStates"]
                BreakAfterJumps=settingstemp["BreakAfterJumps"]
                LineNumberOutput=settingstemp["LineNumberOutput"]
                ListEveryXLines=settingstemp["ListEveryXLines"]
                BreakAfterData=settingstemp["BreakAfterData"]
                TreatDataNumbersAsLineReferences=settingstemp["TreatDataNumbersAsLineReferences"]
                DisplayCommandBytes=settingstemp["DisplayCommandBytes"]
                DisplayComments=settingstemp["DisplayComments"]
                SeperatorMode=settingstemp["SeperatorMode"]
                ShowFlags=settingstemp["ShowFlags"]
                MarkUndocumenedCommand=settingstemp["MarkUndocumenedCommand"]
                XMLOutput=settingstemp["XMLOutput"]
                
            elif(di.instruction&0xFF00==0x0800): #LineNumberOutput
                LineNumberOutput=di.instruction&0x03
                
            elif(di.instruction&0xFF00==0x0900): #ListEveryXLines
                ListEveryXLines=int(di.data,16)

            elif(di.instruction&0xFF00==0x0A00): #BreakAfterData
                BreakAfterData=di.instruction&0x01
                
            elif(di.instruction&0xFF00==0x0B00): #TreatDataNumbersAsLineReferences
                TreatDataNumbersAsLineReferences=di.instruction&0x01
                
            elif(di.instruction&0xFF00==0x0C00): #DisplayCommandBytes
                DisplayCommandBytes=di.instruction&0x01
                
            elif(di.instruction&0xFF00==0x0D00): #DisplayComments
                DisplayCommandBytes=di.instruction&0x01
                
            elif(di.instruction&0xFF00==0x0E00): #SeperatorMode
                SeperatorMode=di.instruction&0x01
                
            elif(di.instruction&0xFF00==0x0F00): #Display flags
                ShowFlags=di.instruction&0x01
                
            elif(di.instruction&0xFF00==0x1000): #note undocumened commands
                MarkUndocumenedCommand=di.instruction&0x01
            
            elif(di.instruction&0xFF00==0x1200): #XML mode
                XMLOutput=di.instruction&0x01

            CurrentFormatEnd=di.end
          
            #set di to next disassemble instruction
            di=DisassembleInstructions.pop(0) if DisassembleInstructions else None
            continue

        #now deal with machine code
      
        #set length for standard command (ignoring any associated data)
        commandlength=1
        #offset to data
        dataOffset=1
        #get opcode details
        s=Z80_OPCODES["base"][data[offset]]
        instructionData=Z80_OPCODE_DATA["base"][data[offset]]
        
        #deal with CB,DD,ED,and FD
        if(s==None):
            if(data[offset]==0xCB):
                s=Z80_OPCODES["CB"][data[offset+1]]
                instructionData=Z80_OPCODE_DATA["CB"][data[offset+1]]
                commandlength=2

            elif(data[offset]==0xED):
                s=Z80_OPCODES["ED"][data[offset+1]]
                instructionData=Z80_OPCODE_DATA["ED"][data[offset+1]]
                commandlength=2
                dataOffset=2
                #convert invalid ED codes to do nothing (is like 2 NOPs)
                if(s==None):
                    s=""
                    instructionData=0x40000000L

            else: #is DD or FD
                dataOffset=2
                codehex="%02X"%data[offset]
                s=Z80_OPCODES[codehex][data[offset+1]]
                instructionData=Z80_OPCODE_DATA[codehex][data[offset+1]]
                #deal with DDCB or FDCB
                if(data[offset+1]==0xCB):
                    commandlength=3
                    s=Z80_OPCODES[codehex+"CB"][data[offset+3]]
                    instructionData=Z80_OPCODE_DATA[codehex+"CB"][data[offset+3]]

                #deal with invalid DD/FD codes (is like a NOP)
                if(s==None):
                    s=""
                    instructionData=0x40000000L
                    commandlength=1

        #now have opcode description in s, number of bytes in command (excluding data) in commandlength,
        #and where to start looking for data in dataOffset
        #data holds information about timing, T states, if needs new line etc
      
        #place in try block to catch trying to get extra data from beyond end of supplied bytes
        try:        
            #first check for & replace displacement byte
            if("d" in s):
                s=s.replace("d",NumberToString(data[offset+dataOffset],8,NumberOutput,True))
                dataOffset+=1
                commandlength+=1
          
            #check for & replace relative jump byte
            if("j" in s):
                #calculate address of next command
                i=currentAddress+commandlength+1
                #add displacement
                i+=data[offset+dataOffset] if (data[offset+dataOffset]<128) else data[offset+dataOffset]-256
              
                s=s.replace("j",NumberToString(i,16,AddressOutput,True))
                dataOffset+=1
                commandlength+=1
              
                #make note of referenced line
                ReferencedLineNumbers+=[i]
          
            #check for & replace 2 byte address
            if("aa" in s):
                #get number
                i=data[offset+dataOffset]+256*data[offset+dataOffset+1]
              
                s=s.replace("aa",NumberToString(i,16,AddressOutput,True))
                dataOffset+=2
                commandlength+=2
              
                #make note of referenced address
                ReferencedLineNumbers+=[i]
          
            #check for & replace 2 byte number
            if("nn" in s):
                #get number
                i=data[offset+dataOffset]+256*data[offset+dataOffset+1]
                
                s=s.replace("nn",NumberToString(i,16,NumberOutput,True))
                dataOffset+=2
                commandlength+=2
                
                #make note of referenced number
                if(TreatDataNumbersAsLineReferences==0):
                     ReferencedLineNumbers+=[i]
          
            #check for & replace 1 byte number
            if("n" in s):
                s=s.replace("n",NumberToString(data[offset+dataOffset],8,NumberOutput,True))
                dataOffset+=1
                commandlength+=1

        #catch if tried to get data from beyond end of supplied data
        except IndexError:
            #have tried to access bytes from beyond end of supplied data
            #output bytes as DB data
            #create DisassembleInsgtruction to do this
            di=DisassembleInstruction(DisassembleInstruction.DisassembleCodes["Data Block"],currentAddress,currentAddress+len(data)-offset-1,DisassembleInstruction.DisassembleDataBlockCodes["Define Byte"])
            #back too start of while loop & should enter data block
            continue
      
        #commandlength now holds number of bytes in current command
        #s holds assembly command
        #now do output

        #Handle XML output
        if(XMLOutput==1):
            soutput+="  <line><address>"+NumberToString(currentAddress,16,AddressOutput,AddressOutput>1)+"</address>"
        
        #handle non-XML
        else:
          #remember line start position in case needed later
          linestartposition=len(soutput)
      
          #work out max length of address
          maxAddressLength=max(FormatAddressLength[AddressOutput],maxAddressLength)
      
          #output address ready for processing later
          i=AddressOutput+(LineNumberOutput<<3)+(SeperatorMode<<5)
          soutput+="\0"+chr(i)+chr(ListEveryXLines)+NumberToString(currentAddress,16,0,False)
      
          #add seperator after address
          soutput+="  " if (SeperatorMode==0) else "\t"
      
          #remember where commands start
          k=len(soutput)-linestartposition
      
        #output bytes of commands
        #Handle XML output
        if(XMLOutput==1):
            soutput+="<bytes>"+",".join([NumberToString(b,8,CommandOutput,False) for b in data[offset:offset+commandlength]])+"</bytes>"

        #handle non-XML
        else:
            #only do if want them output
            if(DisplayCommandBytes==0):
                soutput+=",".join([NumberToString(b,8,CommandOutput,False) for b in data[offset:offset+commandlength]])
            
                #now ensure opcodes line up
                #don't need to bother if using tabs
                if(SeperatorMode==0):
                    i=5*FormatByteLength[CommandOutput]
                    #adjust for commas
                    if(CommandOutput>0):
                        i+=4
                    i+=k
                    i-=len(soutput)-linestartposition
                    while(i>=0):
                        soutput+=" "
                        i-=1
            
            #add seperator after command bytes
            #needed even if no command bytes as can go from disply command bytes to not and have to
            #ensure output stays in same column in case tab seperated output is used in spreadsheet
            soutput+="  " if (SeperatorMode==0) else "\t"
      
        #output opcode
        #Handle XML output
        if(XMLOutput==1):
            soutput+="<instruction>"+s+"</instruction>"
            
        #handle non-XML
        else:
            soutput+=s
      
            #align any comments
            #don't need to bother if using tabs
            if(SeperatorMode==0):
                soutput+=" "*(FormatOpCodeMaxLength[AddressOutput] if FormatOpCodeMaxLength[AddressOutput]>FormatOpCodeMaxLength[NumberOutput] else FormatOpCodeMaxLength[NumberOutput]-len(s))
      
        #Handle XML output of stuff in comments (timing, flags, undocumented commands)
        if(XMLOutput==1):
            #do flags
            sflags=getFlagChanges(instructionData)
            #output flag states if we have them
            if(sflags!=None):
                soutput+="<flags>"+sflags+"</flags>"

            #do times
            #get times
            duration,states=GetTimingInfo(instructionData)
            
            #now output timings
            soutput+="<timeing><cycles>"+str(duration[0])+"</cycles>"
            
            if(states!=None):
                soutput+="<tstates>"+",".join(str(x) for x in states[0])+"</tstates>"

            soutput+="</timeing>"
            
            if(duration[1]!=0):
                soutput+='<timeing alternate="true"><cycles>'+str(duration[1])+"</cycles>"
                
                if(states!=None):
                    soutput+="<tstates>"+",".join(str(x) for x in states[1])+"</tstates>"

                soutput+="</timeing>"
            
            #do undocumented comments if needed
            if(((instructionData>>52)&1)==1):
                soutput+="<undocumented/>"

        #if we're not doing XML and want comments, do so
        elif(DisplayComments==0):
            #space between opcode and comments
            soutput+="  " if (SeperatorMode==0) else "\t"
          
            #output comments
            soutput+=";"
          
            #will we need a space before this comment (and any comment following)
            bNeedSpace=False
          
            #are we listing flags?
            if(ShowFlags>0):
                #get flag states for this instruction
                sflags=getFlagChanges(instructionData)
                #output flag states if we have them
                if(sflags!=None):
                    soutput+=sflags
              
                    #mark will need space if any comment following
                    bNeedSpace=True
          
            if(OutputTStates>0):
                #insert space if needed
                if(bNeedSpace):
                    soutput+="  "
              
                #get times
                duration,states=GetTimingInfo(instructionData)

                #now output timings
                soutput+="T="
                if((OutputTStates&1)==1):
                    soutput+=str(duration[0])
              
                if((OutputTStates&2)==2 and states!=None):
                    soutput+="("+",".join(str(x) for x in states[0])+")"

                if(duration[1]!=0):
                    soutput+="/"
                    if((OutputTStates&1)==1):
                        soutput+=str(duration[1])
                  
                    if((OutputTStates&2)==2 and states!=None):
                        soutput+="("+",".join(str(x) for x in states[1])+")"

                bNeedSpace=True
          
            #are we noteing undocumented commands?
            if(MarkUndocumenedCommand>0 and ((instructionData>>52)&1)==1):
                #do we need gap?
                if(bNeedSpace==True):
                    soutput+="  "
                    
                #record that is undocumented
                soutput+="Undocumented Command"
      
        #end of line
        #Handle XML output
        if(XMLOutput==1):
            soutput+="</line>"

        soutput+="\n"
      
        #do we need to have newline after command to make more readable. Only needed if not doing XML
        i=(instructionData>>31)&3
        if(XMLOutput==0 and BreakAfterJumps!=0 and i!=0):
            if(BreakAfterJumps!=1 or i!=1):
                soutput+="\n"
      
        length-=commandlength
        offset+=commandlength
        offset&=0xFFFF
        currentAddress+=commandlength

    #end 1st pass
    
    if(XMLOutput==1):
        soutput+="</z80code>"

    #now search for line numbers and remove them if not needed
    lastLineInData=-1  #-1 start, 0=last in code, 1=last in data
    #count how many lines since last address reference
    lineCounter=0

    #keep track of where we are in string
    k=0
    
    #search for address markers, only needed if not doing XML
    while(XMLOutput==0):
        #find next or we've finnished
        i=soutput.find("\0",k)
        if(i==-1):
            break
        
        #retrieve Address output formating details
        AddressOutput=ord(soutput[i+1])
        bInData=(AddressOutput&4)==4           #are we in a data block?
        LineNumberOutput=(AddressOutput>>3)&3  #0=All, 1=None, 2=only referenced lines
        SeperatorMode=(AddressOutput>>5)&1     #0=2 spaces, 1=tab
        ListEveryXLines=ord(soutput[i+2])          #list every X lines regardless of LineNumberOutput
        AddressOutput&=3
        
        #if moved from data to code
        if(lastLineInData!=0 and  not bInData):
            #this will force line to be rendered
            lineCounter=ListEveryXLines

        #remember if last in code or data
        lastLineInData=1 if bInData else 0
        
        #increment line counter
        lineCounter+=1
        
        #retrieve address to format
        currentAddress=int(soutput[i+3:i+7],16)
        
        s=""
        if(LineNumberOutput==0 or
           (lineCounter>=ListEveryXLines and ListEveryXLines!=0) or
           (LineNumberOutput==2 and currentAddress in ReferencedLineNumbers) ):
            #output address
            s=NumberToString(currentAddress,16,AddressOutput,AddressOutput>1)
        
            #reset line counter
            lineCounter=0
        
        #if space seperator mode then pad with spaces if needed
        if(SeperatorMode==0):
            k=maxAddressLength-len(s)
            s+=" "*k

        #replace address sting with correct text
        soutput=soutput[:i]+s+soutput[i+7:]
        #point k past line address details
        k=i+len(s)

    return soutput


class DisassembleInstruction:
    DisassembleCodes={
        "Address Output Format Hex":0x0100,
        "Address Output Format Decimal":0x0101,
        "Address Output Format Octal":0x0102,
        "Address Output Format Binary":0x0103,
        "Number Output Format Hex":0x0200,
        "Number Output Format Decimal":0x0201,
        "Number Output Format Octal":0x0202,
        "Number Output Format Binary":0x0203,
        "Command Output Format Hex":0x0300,
        "Command Output Format Decimal":0x0301,
        "Command Output Format Octal":0x0302,
        "Command Output Format Binary":0x0303,
        "Output T States Format None":0x0400,
        "Output T States Format Total":0x0401,
        "Output T States Format List States":0x0402,
        "Output T States Format List All":0x0403,
        "Line After Jump None":0x0500,
        "Line After Jump After Absolute":0x0501,
        "Line After Jump After All":0x0502,
        "Default Format Hex":0x0600,
        "Default Format Decimal":0x0601,
        "Default Format Octal":0x0602,
        "Default Format Binary":0x0603,
        "Custom Format":0x0700,
        "Line Numbers All":0x0800,
        "Line Numbers None":0x0801,
        "Line Numbers Referenced":0x0802,
        "Line Number Every X":0x0900,
        "Empty Line After Data On":0x0A00,
        "Empty Line After Data Off":0x0A01,
        "Reference Data Numbers On":0x0B00,
        "Reference Data Numbers Off":0x0B01,
        "List Command Bytes On":0x0C00,
        "List Command Bytes Off":0x0C01,
        "Comments On":0x0D00,
        "Comments Off":0x0D01,
        "Seperators Space":0x0E00,
        "Seperators Tab":0x0E01,
        "Display Flags Off":0x0F00,
        "Display Flags On":0x0F01,
        "Mark Undocumented Command Off":0x1000,
        "Mark Undocumented Command On":0x1001,
        "Reference Line":0x1100,
        "XML Output Off":0x1200,
        "XML Output On":0x1201,
        "Data Block":0x010000,
        "Pattern Data Block":0x020000}
    
    DisassembleDataBlockCodes={
        "Define Byte Hex":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DB        %#output instruction (DB or define byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0100    %#set format to unsigned
#         %#output '#' to indicate hex number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Define Byte Decimal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DB        %#output instruction (DB or define byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0001    %#set format to decimal
%F0100    %#set format to unsigned
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Define Byte Octal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DB        %#output instruction (DB or define byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0002    %#set format to octal
%F0100    %#set format to unsigned
o         %#output 'o' to indicate octal number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Define Byte Binary":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DB        %#output instruction (DB or define byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0003    %#set format to binary
%F0100    %#set format to unsigned
b         %#output 'b' to indicate binary number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Define Byte":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DB        %#output instruction (DB or define byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0100    %#set format to unsigned
#         %#output '#' to indicate hex number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Signed Byte Hex":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SB        %#output instruction (SB or signed byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0101    %#set format to signed
#         %#output '#' to indicate hex number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Signed Byte Decimal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SB        %#output instruction (SB or signed byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0001    %#set format to decimal
%F0101    %#set format to signed
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Signed Byte Octal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SB        %#output instruction (SB or signed byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0002    %#set format to octal
%F0101    %#set format to signed
o         %#output 'o' to indicate octal number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Signed Byte Binary":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SB        %#output instruction (SB or signed byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0003    %#set format to binary
%F0101    %#set format to signed
b         %#output 'b' to indicate binary number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Signed Byte":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SB        %#output instruction (SB or signed byte in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0101    %#set format to signed
#         %#output '#' to indicate hex number following
%B0F      %#output contents at current position as byte, and increment current position
%$-D      %#close data xml tag""",
        "Define Word Hex":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DW        %#output instruction (DW or define word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0100    %#set format to unsigned
%F0200    %#set words little endian (least significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word Decimal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DW        %#output instruction (DW or define word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0001    %#set format to decimal
%F0100    %#set format to unsigned
%F0200    %#set words little endian (least significant byte first)
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word Octal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DW        %#output instruction (DW or define word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0002    %#set format to octal
%F0100    %#set format to unsigned
%F0200    %#set words little endian (least significant byte first)
o         %#output 'o' to indicate octal number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word Binary":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DW        %#output instruction (DW or define word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0003    %#set format to binary
%F0100    %#set format to unsigned
%F0200    %#set words little endian (least significant byte first)
b         %#output 'b' to indicate binary number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DW        %#output instruction (DW or define word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0100    %#set format to unsigned
%F0200    %#set words little endian (least significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word Hex":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SW        %#output instruction (SW or signed word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0101    %#set format to signed
%F0200    %#set words little endian (least significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word Decimal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SW        %#output instruction (SW or signed word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0001    %#set format to decimal
%F0101    %#set format to signed
%F0200    %#set words little endian (least significant byte first)
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word Octal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SW        %#output instruction (SW or signed word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0002    %#set format to octal
%F0101    %#set format to signed
%F0200    %#set words little endian (least significant byte first)
o         %#output 'o' to indicate octal number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word Binary":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SW        %#output instruction (SW or signed word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0003    %#set format to binary
%F0101    %#set format to signed
%F0200    %#set words little endian (least significant byte first)
b         %#output 'b' to indicate binary number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SW        %#output instruction (SW or signed word in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0101    %#set format to signed
%F0200    %#set words little endian (least significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word BigEndian Hex":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DWBE      %#output instruction (DWBE or define word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0100    %#set format to unsigned
%F0201    %#set words big endian (most significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word BigEndian Decimal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DWBE      %#output instruction (DWBE or define word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0001    %#set format to decimal
%F0100    %#set format to unsigned
%F0201    %#set words big endian (most significant byte first)
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word BigEndian Octal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DWBE      %#output instruction (DWBE or define word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0002    %#set format to octal
%F0100    %#set format to unsigned
%F0201    %#set words big endian (most significant byte first)
o         %#output 'o' to indicate octal number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word BigEndian Binary":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DWBE      %#output instruction (DWBE or define word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0003    %#set format to binary
%F0100    %#set format to unsigned
%F0201    %#set words big endian (most significant byte first)
b         %#output 'b' to indicate binary number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Define Word BigEndian":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
DWBE      %#output instruction (DWBE or define word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0100    %#set format to unsigned
%F0201    %#set words big endian (most significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word BigEndian Hex":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SWBE      %#output instruction (SWBE or signed word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0101    %#set format to signed
%F0201    %#set words big endian (most significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word BigEndian Decimal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SWBE      %#output instruction (SWBE or signed word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0001    %#set format to decimal
%F0101    %#set format to signed
%F0201    %#set words big endian (most significant byte first)
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word BigEndian Octal":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SWBE      %#output instruction (SWBE or signed word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0002    %#set format to octal
%F0101    %#set format to signed
%F0201    %#set words big endian (most significant byte first)
o         %#output 'o' to indicate octal number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word BigEndian Binary":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SWBE      %#output instruction (SWBE or signed word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0003    %#set format to hexadecimal
%F0101    %#set format to signed
%F0201    %#set words big endian (most significant byte first)
b         %#output 'b' to indicate binary number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",
        "Signed Word BigEndian":
"""%$A       %#start address xml tag
%F0004    %#set output format to general output format
%ACA      %#output line address as address
%$-A      %#close address xml tag
%S%S      %#seperator
%$I       %#start instruction xml tag
SWBE      %#output instruction (SWBE or signed word big endian in this case)
%$-I      %#close instruction tag
%S        %#seperator
%$D       %#start data tag
%F0000    %#set format to hexadecimal
%F0101    %#set format to signed
%F0201    %#set words big endian (most significant byte first)
#         %#output '#' to indicate hex number following
%W0F      %#output contents at current position as word, and increment current position
%$-D      %#close data xml tag""",

        "Define Message":
"""%$A             %#start address xml tag
%F0004          %#set output format to general output format
%ACA            %#output line address as address
%$-A            %#close address xml tag
%S%S            %#seperator
%$I             %#start instruction xml tag
DM              %#output instuction (DM or Define Message)
%$-I            %#close instruction xml tag
%S
%$D             %#start data tag
%X01000000      %#set var0 to 0 (used as flag: 0=outside quotes, 1=inside quotes)
%L%(            %#define loop,staring with the while condition
  %?LE%V0F%V0E  %#while current position is less than end position
%)              %#end while test
%(              %#start of loop section
  %I%(          %#start of if
    %(%?EQ%V000001                              %#if we're inside quotes
      %?BA                                      %#and
      %(%?LT%MV0F0020                           %#the contents of the current position are less than 0x20 (ie is not ascii character)
        %?BO                                    %#or
        %(%?MT%MV0F007F%?BA%?LT%MV0F00A3%)%)%)  %#the contents of the current position are greater than 0x7F, and less than 0xA3 (not printable character: NB codes A3 and above are valid printable spectrum characters - the commands)
    %?BO                                        %#or
    %(%?EQ%V000000                              %#we're not inside quotes
      %?BA                                      %#and
      %(%?MT%MV0F00A2                           %#the contents of the current position is a command: valid spectrum character
        %?BO                                    %#or
        %(%?MT%MV0F001F%?BA%?LT%MV0F0080%)%)%)  %#the contents of the current position are >0x1F and <0x80 (ie valid character)
  %)                %#end if test
  %(                %#are we in a quote & have an unprintable character or outside a quote, and have a printable character
    "               %#print a quote
    %X03000001%V00  %#take var0 from 1 and store in var0: toggles var0 swapping from inside to outside quotes and vice versa
  %)                %#end if action
  %C0F              %#output contents at current position as character, and increment current position
%)                  %#end while loop
%I%(                %#if to see if still inside quotes
  %?EQ%V000001      %#is var0 equal to 1
%)
%(
  "                 %#print closeing quote if we are
%)
%$-D      %#close data xml tag""",
        "Define Message zero terminated":
"""%$A             %#start address xml tag
%F0004          %#set output format to general output format
%ACA            %#output line address as address
%$-A            %#close address xml tag
%S%S            %#seperator
%$I             %#start instruction xml tag
DM0             %#output instuction (DM0 or Define Message 0 ternminated)
%$-I            %#close instruction xml tag
%S
%$D             %#start data tag
%X01000000      %#set var0 to 0 (used as flag: 0=outside quotes, 1=inside quotes)
%L%(            %#define while condition for loop
  %?NE%MV0F0000 %#while the contents of the current position are not equal to 0
%)
%(              %#start of loop section
  %I%(          %#start of if
    %(%?EQ%V000001                              %#if we're inside quotes
      %?BA                                      %#and
      %(%?LT%MV0F0020                           %#the contents of the current position are less than 0x20 (ie is not ascii character)
        %?BO                                    %#or
        %(%?MT%MV0F007F%?BA%?LT%MV0F00A3%)%)%)  %#the contents of the current position are greater than 0x7F, and less than 0xA3 (not printable character: NB codes A3 and above are valid printable spectrum characters - the commands)
    %?BO                                        %#or
    %(%?EQ%V000000                              %#we're not inside quotes
      %?BA                                      %#and
      %(%?MT%MV0F00A2                           %#the contents of the current position is a command: valid spectrum character
        %?BO                                    %#or
        %(%?MT%MV0F001F%?BA%?LT%MV0F0080%)%)%)  %#the contents of the current position are >0x1F and <0x80 (ie valid character)
  %)                %#end if test
  %(                %#are we in a quote & have an unprintable character or outside a quote, and have a printable character
    "               %#print a quote
    %X03000001%V00  %#take var0 from 1 and store in var0: toggles var0 swapping from inside to outside quotes and vice versa
  %)                %#end if action
  %C0F              %#output contents at current position as character, and increment current position
%)                  %#end while loop
%I%(                %#if to see if still inside quotes
  %?EQ%V000001      %#is var0 equal to 1
%)
%(
  "                 %#print closeing quote if we are
%)
,                   %#print comma
%X020C%V0C0001      %#add offset from linestart and 1 and save as offset from line start. moves past 0 terminating byte
#00                 %#print #00 as for terminating 0x00
%$-D                %#close data xml tag""",
        "Define Message bit 7 terminated":
"""%$A             %#start address xml tag
%F0004          %#number format to same as general address format
%ACA            %#output line address (variable 0x0A) as an address, don't increment line address(set bit 6), is variable and not what points to we want (bit 7)
%$-A            %#close address xml tag
%S%S            %#seperator
%$I             %#start instruction xml tag
DM7             %#output instuction (DM7 or Define Message bit7 ternminated)
%$-I            %#close instruction xml tag
%S
%$D             %#start data tag
%X01000000         %#set var0 to 0 (used as flag: 0=outside quotes, 1=inside quotes)
%L%(               %#enter while() do{} loop
  %?EQ00000000     %# 0==0: ie true. this will loop until loop is broken out of
%)                 %#end of while test
%(                 %#enter do part of loop
  %X0701%MV0F007F  %#set var1 to contents of current position & 0x7F
  %X0702%MV0F0080  %#set var2 to contents of current position & 0x80
  %X020C%V0C0001   %#increment current position
  %I%(             %#check if entering or leaving printable character
    %( %?EQ%V000001 %?BA %?LT%V010020 %)   %#if in quotes & var1<0x20
    %?BO           %#or
    %( %?EQ%V000000 %?BA %?MT%V01001F %)   %#if not in quotes & var1>0x1F
  %)               %#end of if test
  %(               %#start of what to do if test true
    "              %#output quotes
    %X03000001%V00 %#set var0 to 1-var0 (so will set to 1 if was 0 and 0 if was 1: toggles if in quotes)
  %)               %#end if action
  %CC1             %#output character: var1 (what's at current position&0x7F) (bit 6=don't increment, bit7=contents of address pointer to by current address register)
  %I%(             %#start if
    %?EQ%V020080   %#is var2==0x80 (ie was bit 7 set in currentcharacter before incrementing?
  %)               %#end of if test
  %(               %#start of what to do if test true
    %Y             %#break out of loop: as have reached character with bit 7 set
  %)               %#end if action
%)                 %#end of loop

%I%(               %#start of if
  %?EQ%V000001     %#if var0==1 (is inside a quote)
%)                 %#end of if test
%(                 %#start of what to do if test true
  "                %#print closing quote
%)                 %#end of what to do if test true
%$-D                %#close data xml tag""",
        "Define Message Length Byte":
"""%$A            %#start address xml tag
%F0004         %#number format to same as general address format
%ACA           %#output line address (variable 0x0A) as an address, don't increment line address(set bit 6), is variable and not what points to we want (bit 7)
%$-A           %#close address xml tag
%S%S           %#seperator
%$I            %#start instruction xml tag
DMLB           %#output instuction (DMLB or Define Message Length Byte)
%$-I           %#close instruction xml tag
%S
%$D            %#start data tag
%X01000000     %#set var0 to 0 (used as flag: 0=outside quotes, 1=inside quotes)
%X0101%MV0F    %#var1 to contents of current address (number of bytes in string)
%X020C%V0C0001 %#increment current position to point to 1st byte of string

%L%(           %#enter while() do{} loop
  %?MT%V010000 %# Var1>0: ie true while still have characters to print
%)             %#end of while test
%(             %#enter do part of loop
  %I%(         %#enter if check
    %(%?EQ%V000001 %?BA %(%?LT%MV0F0020 %?BO %(%?MT%MV0F007F %?BA %?LT%MV0F00A3%)%)%) %#if in quotes & not prinatable character
    %?BO       %#or
    %(%?EQ%V000000 %?BA %(%?MT%MV0F00A2 %?BO %(%?MT%MV0F001F %?BA %?LT%MV0F0080%)%)%) %#not in quotes & printable character
  %)               %#end condition block
  %(               %#start block if true
    "              %#print quote
    %X03000001%V00 %#toggle var1 stateing in quotes
  %)
  %C0F             %#print char at current position, and increase current position
  %X0301%V010001   %#decrement var1 by 1
%)                 %#end loop
%I%(               %#start if block
  %?EQ%V000001     %#are we in quotes
%)
%(
  "                %#if so print close quotes
%)
%$-D                %#close data xml tag""",
        "Define Message Length Word":
"""%$A            %#start address xml tag
%F0004         %#number format to same as general address format
%ACA           %#output line address (variable 0x0A) as an address, don't increment line address(set bit 6), is variable and not what points to we want (bit 7)
%$-A           %#close address xml tag
%S%S           %#seperator
%$I            %#start instruction xml tag
DMLW           %#output instuction (DMLW or Define Message Length Word)
%$-I           %#close instruction xml tag
%S
%$D            %#start data tag
%X01000000     %#set var0 to 0 (used as flag: 0=outside quotes, 1=inside quotes)
%F0200         %#set little endian
%X0101%MWV0F   %#set var1 to contents of current address (number of bytes in string)
%X020F%V0F0002 %#increment current position to point to 1st byte of string

%L%(           %#enter while() do{} loop
  %?NE%V010000 %# Var1!=0: ie true while still have characters to print
%)             %#end of while test
%(             %#enter do part of loop
  %I%(         %#enter if check
    %(%?EQ%V000001 %?BA %(%?LT%MV0F0020 %?BO %(%?MT%MV0F007F %?BA %?LT%MV0F00A3%)%)%) %#if in quotes & not prinatable character
    %?BO       %#or
    %(%?EQ%V000000 %?BA %(%?MT%MV0F00A2 %?BO %(%?MT%MV0F001F %?BA %?LT%MV0F0080%)%)%) %#not in quotes & printable character
  %)               %#end condition block
  %(               %#start block if true
    "              %#print quote
    %X03000001%V00 %#toggle var1 stateing in quotes
  %)
  %C0F             %#print char at current position, and increase current position
  %X0301%V010001   %#decrement var1 by 1
%)                 %#end loop
%I%(               %#start if block
  %?EQ%V000001     %#are we in quotes
%)
%(
  "                %#if so print close quotes
%)
%$-D                %#close data xml tag""",
        "Define Message Length Word Bigendian":
"""%$A            %#start address xml tag
%F0004         %#number format to same as general address format
%ACA           %#output line address (variable 0x0A) as an address, don't increment line address(set bit 6), is variable and not what points to we want (bit 7)
%$-A           %#close address xml tag
%S%S           %#seperator
%$I            %#start instruction xml tag
DMLWBE         %#output instuction (DMLWBE or Define Message Length Word Big Endian)
%$-I           %#close instruction xml tag
%S
%$D            %#start data tag
%X01000000     %#set var0 to 0 (used as flag: 0=outside quotes, 1=inside quotes)
%F0201         %#set big endian
%X0101%MWV0F   %#set var1 to contents of current address (number of bytes in string)
%X020F%V0F0002 %#increment current position to point to 1st byte of string

%L%(           %#enter while() do{} loop
  %?NE%V010000 %# Var1!=0: ie true while still have characters to print
%)             %#end of while test
%(             %#enter do part of loop
  %I%(         %#enter if check
    %(%?EQ%V000001 %?BA %(%?LT%MV0F0020 %?BO %(%?MT%MV0F007F %?BA %?LT%MV0F00A3%)%)%) %#if in quotes & not prinatable character
    %?BO       %#or
    %(%?EQ%V000000 %?BA %(%?MT%MV0F00A2 %?BO %(%?MT%MV0F001F %?BA %?LT%MV0F0080%)%)%) %#not in quotes & printable character
  %)               %#end condition block
  %(               %#start block if true
    "              %#print quote
    %X03000001%V00 %#toggle var1 stateing in quotes
  %)
  %C0F             %#print char at current position, and increase current position
  %X0301%V010001   %#decrement var1 by 1
%)                 %#end loop
%I%(               %#start if block
  %?EQ%V000001     %#are we in quotes
%)
%(
  "                %#if so print close quotes
%)
%$-D                %#close data xml tag""",
        "Custom":""
        }

    #so can tell order
    DisassembleDataBlockCodeOrderedKeys=(
        "Define Byte Hex",
        "Define Byte Decimal",
        "Define Byte Octal",
        "Define Byte Binary",
        "Define Byte",
        "Signed Byte Hex",
        "Signed Byte Decimal",
        "Signed Byte Octal",
        "Signed Byte Binary",
        "Signed Byte",
        "Define Word Hex",
        "Define Word Decimal",
        "Define Word Octal",
        "Define Word Binary",
        "Define Word",
        "Signed Word Hex",
        "Signed Word Decimal",
        "Signed Word Octal",
        "Signed Word Binary",
        "Signed Word",
        "Define Word BigEndian Hex",
        "Define Word BigEndian Decimal",
        "Define Word BigEndian Octal",
        "Define Word BigEndian Binary",
        "Define Word BigEndian",
        "Signed Word BigEndian Hex",
        "Signed Word BigEndian Decimal",
        "Signed Word BigEndian Octal",
        "Signed Word BigEndian Binary",
        "Signed Word BigEndian",
        "Define Message",
        "Define Message zero terminated",
        "Define Message bit 7 terminated",
        "Define Message Length Byte",
        "Define Message Length Word",
        "Define Message Length Word Bigendian",
        "Custom")
        
    DisassemblePatternBlockCodes={
        "RST#08 (Error)":
"""%(               %#start test block
  %?EQ%MV0F00CF  %#does the first byte equal 0xCF (code for RST #08)
%)               %#end test block

%(               %#block to define first & last address of data block
  %X0200%V0F0001 %#start position (var0) is position of RST #08 command +1
  %X0101%V00     %#end position (var1) is start position (only 1 byte affter error restart)
%)               %#end variable setup block
                 %#start of data handling block
%S%S
%$I              %#start instruction xml tag
DEFB             %#output instuction (DEFB or Define Byte)
%$-I             %#close instruction xml tag
%S
%$D              %#start data tag
%F0000           %#set hex mode
%F0100           %#set unsigned
#%B0F            %#output contents of current address as byte and increment current address
%$-D             %#close data tag""",
        "RST#28 (Calculator)":
"""%(                 %#start test block
  %?EQ%MV0F00EF    %#does the first byte equal 0xEF (code for RST #28)
%)                 %#end test block

%(                 %#block to define first & last address of data block
  %X0200%V0F0001   %#start position (var0) is position of RST #28 command +1
  %X0101%V00       %#set end pos (var1) is start position
  %L%(
    %?NE%MV010038  %#loop until reach a byte #38 used to denote end of calculate
  %)
  %(
    %X0201%V010001 %#add 1 to end pos (var1) each time byte is not #38
  %)
%)                 %#end variable setup block

                   %#start of data handling block
%S%S
%$I                %#start instruction xml tag
DEFB               %#output instuction (DEFB or Define Byte)
%$-I               %#close instruction xml tag
%S
%$D                %#start data tag
%F0000             %#set hex mode
%F0100             %#set unsigned
#%B0F              %#output contents of current address as byte and increment current address
%$-D               %#close data tag""",
        "Custom":""
    }

    DisassemblePatternBlockCodeOrderedKeys=(
        "RST#08 (Error)",
        "RST#28 (Calculator)",
        "Custom")

    def __init__(self,arg,start=0,end=65536,data=None):
        """
        Creates a new DisassembleInstruction which is used to control disassembly of Z80 code.
        
        The only required argument is either a DisassembleInstruction to copy, an int of the
        instruction to carry out, or a string with a packed DisassembleInstruction in it (see
        __str__() for packing this string.
        
        Optional arguments are ignored for everything other than an initial int argument. They
        are:
        start is the address from where this instruction applies.
        end is the address up to and including that this instruction applies.
        data is a string that is needed by the DisassembleInstruction to carry out it's instructions.
        """

        #if constructor arg is another DisassembleInstruction then make a copy
        if(isinstance(arg,DisassembleInstruction)):
            data=None if arg.data==None else str(arg.data)
            end=arg.end
            start=arg.start
            arg=arg.instruction

        #if argument is string for instruction type then get code
        if(arg in DisassembleInstruction.DisassembleCodes):
            arg=DisassembleInstruction.DisassembleCodes[arg]

        #if constructor arg is a string then unpack the contained data
        if(isinstance(arg,str)):
            #break data into components
            parts=arg.split("#",4)
            arg=int(parts[0],16)
            start=int(parts[1],16)
            end=int(parts[2],16)
            data=parts[4] if len(parts)==5 else None
            #handle multiline data
            if(len(parts[3])>0):
                #re-insert newline characters
                for pos in parts[3].split(','):
                    pos=int(pos,16)
                    data=data[:pos]+"\n"+data[pos:]

        self.instruction=arg
        self.start=start
        self.end=end
        #make copy of string
        self.data=None if data==None else str(data)


    def is_format_instruction(self):
        """Tests if the DisassembleInstruction is a format instruction."""
        
        return self.instruction!=0 and (self.instruction&0xFF0000)==0

    def __str__(self):
        """
        Returns a String representation of the DisassembleInstruction. This is the instruction code in hexadecimal,
        followed by a '#' followed by the start address in hexadecimal, followed by a '#', followed by the end
        address in hexadecimal, followed by a '#'. If the data property is not None then a comma seperated list
        of positions for new line characters in the data field follows, then another '#', and then the data
        field with newline characters stripped out.
        
        This can be used as an argument to the constructor to create a new DisassembleInstruction
        """
        
        if(self.data==None):
            return "%X#%X#%X#" % (self.instruction,self.start,self.end)

        return "%X#%X#%X#%s#%s" % (self.instruction,self.start,self.end,
        ','.join(["%X" % i for i,c in enumerate(self.data) if c=='\n']),self.data.replace('\n',''))

    def __cmp(self,other):
        return self.start.__cmp__(other.start)

    def DisassembleDataBlock(self,Settings,data,ReferencedLineNumbers):
        """
        This method will disassemble the given data according to the current DisassembleInstruction
        """
        
        """
        var[0-9]  %V00-%V09
        line address (not changable)  %V0A
        line number (not changable)   %V0B
        offset from line start        %V0C
        start pos (not changable)     %V0D
        end pos                       %V0E
        current pos (not changable)   %V0F
        """
        Vars=[0,0,0,0,0,0,0,0,0,0,self.start,0,0,self.start,self.end]
        soutput=""

        #loop through commandline block
        while(Vars[0x0A]<=Vars[0x0E]):
            Vars[0x0C]=0  #point  to start of line
    
            #for each line go through commandline instructions character by chracter
            Settings["DATASTRINGPOS"]=0

            #output start line if needed
            if(Settings["XMLOutput"]==1):
                soutput+='  <line>'

            while(Settings["DATASTRINGPOS"]<len(self.data)):
                #make note of where command starts in case we have error
                commandstart=Settings["DATASTRINGPOS"]
              
                #get next char
                s=GetNextCharacters(self.data,Settings,1)
                
                if(s==""):
                    break
              
                #deal with non-control characters first
                if(s[0]!='%'):
                    soutput+=get_spec_char(s[0])
                    continue
              
                #reset position
                Settings["DATASTRINGPOS"]=commandstart
              
                #deal with any instructions
                #can ignore result
                res,txt=ProcessCommandBlock(self.data,Vars,Settings,data,False,False,ReferencedLineNumbers)
                    
                soutput+=txt
          
            #update line address
            Vars[0x0A]+=Vars[0x0C]
            #update line number
            Vars[0x0B]+=1
          
            #output end start line if needed
            if(Settings["XMLOutput"]==1):
                soutput+='</line>'

            #new line
            soutput+="\n"
    
        #return end of data block as might have changed
        return Vars[0x0E],soutput

def NumberToString(n,bits,form,typeindicator=True):
    """
    format: 0=hex,1=decimal,2=octal,3=binary
    typeindictor specifies display type specifer before number: ""for decimal, "#" for hex, "b" for binary, "o" for octal
    """
    if(form==0):
        #hex
        return ("%s%0"+str(bits>>2)+"X") % ("#" if typeindicator else "",n)
    
    elif(form==1):
        #decimal
        return "%d" % n
    
    elif(form==2):
        #octal
        return ("%s%0"+str((bits+2)/3)+"o") % ("o" if typeindicator else "",n)

    elif(form==3):
        #binary
        return ("%s%0"+str(bits)+"b") % ("b" if typeindicator else "",n)

    else:
        return ""

def GetNextCharacters(instructions,Settings,numberToGet):
    """
    returns required number of characters skipping space, new line, tabs, and comments.
    """
    
    s=""

    #loop until have requested number of non whitespace characters or hit end of commands
    while(len(s)<numberToGet and Settings["DATASTRINGPOS"]<len(instructions)):
        c=instructions[Settings["DATASTRINGPOS"]]

        #if found comment, move to end of line
        if(c=='%' and len(instructions)>Settings["DATASTRINGPOS"]+1 and instructions[Settings["DATASTRINGPOS"]+1]=="#"):
            #check just incase have %%# which is display %#
            escapes=1
            #see how far back escapes go back
            while(escapes>Settings["DATASTRINGPOS"] and instructions[Settings["DATASTRINGPOS"]-escapes]=="%"):
                escapes+=1
            
            #should have an odd number of escapes if this a comment
            if(escapes&1==1):
                #move position to new line character
                Settings["DATASTRINGPOS"]=instructions.find("\n",Settings["DATASTRINGPOS"])
                #if newline not found,
                if(Settings["DATASTRINGPOS"]==-1):
                    #set to end of line
                    Settings["DATASTRINGPOS"]=len(instructions)
                
                #loop back to deal with next character    
                continue
            
            #otherwise is a hash to display

        if(c!=' ' and c!='\t' and c!='\n'):
            s+=c
        Settings["DATASTRINGPOS"]+=1
    
    return s

def MoveToEndBlock(instructions,Vars,Settings,commandstart):
    """
    move to end of specified command block
    """
    
    #for each line go through commands instructions character by chracter
    while(Settings["DATASTRINGPOS"]<len(instructions)):
        #get next char
        s=GetNextCharacters(instructions,Settings,1)
        
        if(s==""):
            break
      
        #skip non-control characters first
        if(s!="%"):
            continue
      
        #get next char
        s=GetNextCharacters(instructions,Settings,1)
        
        if(s==""):
            break
      
        #what command is it?
        if(s[0]=="("):
            #move to end of nested block
            MoveToEndBlock(instructions,Vars,Settings,commandstart)

        #return if found end of block
        elif(s[0]==')'):
            return
        
        #otherwise skip command

    #should always find end of block with close brackets, error if block not closed
    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"no closing brackets to  block")

def ProcessCommandBlock(instructions,Vars,Settings,data,inBrackets,InTest,ReferencedLineNumbers):
    """processes an instruction block.
       return bit 0 1=true, 0=false
       bit 1 2=break, 0=not break
       bit 2 4=continue, 0=not continue
       ,output text
    """

    #nested functions needed by ProcessCommandBlock
    def inc_var_if_needed(var_num,Vars,inc_amount):
        """increment variable if apropriate"""
        if((var_num&0x40)==0 and ((var_num&0x3F)<0x0A or (var_num&0x3F)==0x0C or (var_num&0x3F)==0x0F)):
            Vars[0x0C if ((var_num&0x3F)==0x0F) else var_num&0x3F]+=inc_amount

    def GetNumberVarOrMemory(instructions,Vars,Settings,data,commandstart):
        #how many bytes are we getting
        getByte=True;
        #remember where we started
        pos=Settings["DATASTRINGPOS"]
        
        #get next char
        s=GetNextCharacters(instructions,Settings,1)

        if(s==""):
            raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Invalid variable or number definition")
        
        #first check if is a number
        if(s[0]!="%"):
            #restore pointer to where it was
            Settings["DATASTRINGPOS"]=pos
          
            #extract number
            i=int(GetNextCharacters(instructions,Settings,4),16)
            #deal with error
            if(i<0):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"number must be 4 digit hexadecimal number")

            return i
        
        #get next char
        s=GetNextCharacters(instructions,Settings,1)
        
        if(s[0]=="V"):
            #get variable number
            i=int(GetNextCharacters(instructions,Settings,2),16)
            #deal with invalid variable number
            if(i<0 or i>0x0F):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid variable")
                
            #return variable's content
            return Vars[0x0A]+Vars[0x0C] if (i==0x0F) else Vars[i]
        
        #should now be 'M', handle if not
        if(s[0]!="M"):
            raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"argument must be number, variable, or memory content")
        
        pos=Settings["DATASTRINGPOS"]
        
        #get next char
        s=GetNextCharacters(instructions,Settings,1)
        
        #if next char is 'W' then need to get 2 bytes
        if(s[0]=="W"):
            #make note we need word not byte
            getByte=False
        
            #get next char
            s=GetNextCharacters(instructions,Settings,1)
        
            pos=Settings["DATASTRINGPOS"]
        
        #now get into i address of where to extract data from
        
        #if next char is 'V' then variable pointing to memory address
        if(s[0]=="V"):
            #get variable number
            i=int(GetNextCharacters(instructions,Settings,2),16)
            #deal with invalid variable number
            if(i<0 or i>0x0F):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid variable number for memory address")
                
            #get number variable's content
            i=Vars[0x0A]+Vars[0x0C] if (i==0x0F) else Vars[i]

        #otherwise should be 4 hex digit address
        else:
            #in checking to see if next char was V will move pointer, so reset to where it should be
            Settings["DATASTRINGPOS"]=pos
          
            #extract number
            i=int(GetNextCharacters(instructions,Settings,4),16)
            #deal with error
            if(i<0):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"should be 4 digit hexadecimal number for memory address")
        
        #now have address we need to extract in i, and if we want byte or not in getByte
        #deal with byte
        if(getByte):
            return data[i-Settings["ORIGIN"]]
            #throw NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"attempt to access memory address outside block to disassemble");
        
        #deal with word taking into account endedness of number we want
        return data[i-Settings["ORIGIN"]+Settings["NUMBERWORDORDER"]]+256*data[i-Settings["ORIGIN"]+1-Settings["NUMBERWORDORDER"]]
          #throw NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"attempt to access memory address outside block to disassemble");

    def CombineResults(mode,a,b):
        if(mode==0):
            return a and b
        if(mode==1):
            return a or b
        if(mode==2):
            return a^b

    #end of ProcessCommandBlock's nested functions

    boolState=False
    boolMode=1      #0=and, 1=or, 2=xor
    soutput=""

    #for each line go through commands instructions character by chracter
    while(Settings["DATASTRINGPOS"]<len(instructions)):
        #make note of where command starts in case we have error
        commandstart=Settings["DATASTRINGPOS"]
      
        #get next char
        s=GetNextCharacters(instructions,Settings,1)
        
        if(s==""):
            break
      
        #deal with non-control characters first
        if(s[0]!='%'):
            soutput+=get_spectrum_char(s[0])
            continue

        #get next char (command
        s=GetNextCharacters(instructions,Settings,1)
      
        #what command is it?
        if(s[0]=='F'): #//format settings
            #get sub command & which format
            i=int(GetNextCharacters(instructions,Settings,4),16)
            if((i>>8)==0): #format hex/decimal/octal/binary
                if((i&0xFF)>6):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Number format argument must be 0 to 6")
                    
                if((i&0xFF)==4):
                    Settings["NUMBERFORMAT"]=Settings["ADDRESSOUTPUT"]
                    
                elif((i&0xFF)==5):
                    Settings["NUMBERFORMAT"]=Settings["NUMBEROUTPUT"]
                    
                elif((i&0xFF)==6):
                    Settings["NUMBERFORMAT"]=Settings["COMMANDOUTPUT"]
                    
                else:
                    Settings["NUMBERFORMAT"]=i&0xFF

            elif((i>>8)==1): #number unsigned/signed
                if((i&0xFF)>1):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Number sign argument must be 0 or 1")
                
                Settings["NUMBERSIGNED"]=i&0xFF

            elif((i>>8)==2): #word mode little/big endian
                if((i&0xFF)>1):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Word endedness argument must be 0 or 1")
                
                Settings["NUMBERWORDORDER"]=i&0xFF

            elif((i>>8)==3): #display line address every X line
                k=int(GetNextCharacters(instructions,Settings,2),16)
                if(k<0 or k>255):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Display line address every X line argument must be 2 digit hexadecimal number")
                    
                Settings["DISPLAYEVERYXLINES"]=k+((i&0xFF)<<8)

            elif((i>>8)==4): #separator to default/space/tab
                if((i&0xFF)>2):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Seperator setting argument must be 0 to 2")
                    
                Settings["SEPERATOR"]=i&0xFF
                if(Settings["SEPERATOR"]==2):
                    Settings["SEPERATOR"]=Settings["ORIGIONALSEPERATOR"]
                    
            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"unrecognised format setting")
      
        elif(s[0]=='B'): #ouput byte
            #get info
            i=int(GetNextCharacters(instructions,Settings,2),16)
            if((i&0x3F)==0x3F): #dealing with addresses
                #get address
                k=int(GetNextCharacters(instructions,Settings,4),16)
                #getbyte at address, adjust for offset
                k=data[k-Settings["ORIGIN"]]
            
            elif((i&0x3F)<0x10):
                #get variable content
                k=Vars[0x0A]+Vars[0x0C] if ((i&0x3F)==0x0F) else Vars[i&0x3F]
                #get content of memory address if this is a reference
                if((i&0x80)==0):
                    k=data[k-Settings["ORIGIN"]]
                #increment if apropriate
                inc_var_if_needed(i,Vars,1)

            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid byte output argument")
      
            #handle negative number if signed and not an address
            if(Settings["NUMBERSIGNED"]==1 and (i&0x80)==0x80):
                k=0x100-k
                soutput+="-"

            #output byte
            soutput+=NumberToString(k,8,Settings["NUMBERFORMAT"],False)
      
        elif(s[0]=='W'): #output word
            #get info
            i=int(GetNextCharacters(instructions,Settings,2),16)
            if((i&0x3F)==0x3F):  #dealing with addresses
                #get address
                k=int(GetNextCharacters(instructions,Settings,4),16)
                #getbyte, adjust for offset
                k=data[k-Settings["ORIGIN"]+Settings["NUMBERWORDORDER"]]+256*data[k-Settings["ORIGIN"]+1-Settings["NUMBERWORDORDER"]]

            elif((i&0x3F)<0x10):
                #get variable content
                k=Vars[0x0A]+Vars[0x0C] if ((i&0x3F)==0x0F) else Vars[i&0x3F]
                #get content of memory address if this is a reference
                if((i&0x80)==0):
                    k=data[k-Settings["ORIGIN"]+Settings["NUMBERWORDORDER"]]+256*data[k-Settings["ORIGIN"]+1-Settings["NUMBERWORDORDER"]]
                    
                #increment if apropriate
                inc_var_if_needed(i,Vars,2)

            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid number output argument")
      
            #handle negative number if signed and not an addrss
            if(Settings["NUMBERSIGNED"]==1 and (i&0x80)==0x80):
                k=0x100-k
                soutput+="-"

            #output word
            soutput+=NumberToString(k,16,Settings["NUMBERFORMAT"],False)
            #remember number incase it is line number
            if(ReferencedLineNumbers!=None):
                ReferencedLineNumbers+=[k]
      
        elif(s[0]=='A'): #output address
            #get info
            i=int(GetNextCharacters(instructions,Settings,2),16)
            if((i&0x3F)==0x3F): #dealing with addresses
                #get address
                k=int(GetNextCharacters(instructions,Settings,4),16)
                #getbyte, adjust for offset
                k=data[k-Settings["ORIGIN"]+Settings["NUMBERWORDORDER"]]+256*data[k-Settings["ORIGIN"]+1-Settings["NUMBERWORDORDER"]]

            elif((i&0x3F)<0x10):
                #get variable content
                k=Vars[0x0A]+Vars[0x0C] if ((i&0x3F)==0x0F) else Vars[i&0x3F]
                #get content of memory address if this is a reference
                if((i&0x80)==0):
                    k=data[k-Settings["ORIGIN"]+Settings["NUMBERWORDORDER"]]+256*data[k-Settings["ORIGIN"]+1-Settings["NUMBERWORDORDER"]]
                #increment if apropriate
                inc_var_if_needed(i,Vars,2)

            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid address output argument")
      
            #output address
            if(Settings["XMLOutput"]==1):
                soutput+=NumberToString(k,16,Settings["NUMBERFORMAT"],False)

            else:
                i=Settings["NUMBERFORMAT"]+4+(Settings["SEPERATOR"]<<5)
                soutput+="\0"+chr(i)+chr(Settings["DISPLAYEVERYXLINES"])+NumberToString(k,16,0,False)
      
        elif(s[0]=='C'):  #output char, defaults to unsigned byte if not printable
            #get info
            i=int(GetNextCharacters(instructions,Settings,2),16)
            if((i&0x3F)==0x3F): #dealing with addresses
                #get address
                k=int(GetNextCharacters(instructions,Settings,4),16)
                #getbyte, adjust for offset
                k=data[k-Settings["ORIGIN"]]

            elif((i&0x3F)<0x10):
                #get variable content
                k=Vars[0x0A]+Vars[0x0C] if ((i&0x3F)==0x0F) else Vars[i&0x3F]
                #get content of memory address if this is a reference
                if((i&0x80)==0):
                    k=data[k-Settings["ORIGIN"]]
                #increment if apropriate
                inc_var_if_needed(i,Vars,1)

            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid character output argument")
      
            #output character
            soutput+=get_spectrum_char(k)
      
        elif(s[0]=='G'):  #output 5 byte floating point number
            #get info
            i=int(GetNextCharacters(instructions,Settings,2),16)
            if((i&0x3F)==0x3F):  #dealing with addresses
                #get address
                k=int(GetNextCharacters(instructions,Settings,4),16)
                #get and output floating point number
                soutput+=str(SpectrumNumber(data[k-Settings["ORIGIN"]:k-Settings["ORIGIN"]+5]))

            elif((i&0x3F)<0x10):
                #get variable content
                k=Vars[0x0A]+Vars[0x0C] if ((i&0x3F)==0x0F) else Vars[i&0x3F]
                #has to be a memory address that holds 5 byte number
                if((i&0x80)!=0):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid floating point number output argument")
              
                #get and output floating point number
                soutput+=str(SpectrumNumber(data[k-Settings["ORIGIN"]:k-Settings["ORIGIN"]+5]))
                #increment if apropriate
                inc_var_if_needed(i,Vars,5)

            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid floating point number output argument")
      
        elif(s[0]=='%'):  #output '%'
            soutput+='%'
      
        elif(s[0]=='S'):  #output seperator
            #only output if not in xml mode
            if(Settings["XMLOutput"]==0):
                soutput+="  " if Settings["SEPERATOR"]==0 else "\t"
      
        elif(s[0]=='N'):  #output newline
            soutput+='\n'
      
        elif(s[0]==' '):  #output space
            soutput+=' '
      
        elif(s[0]=='T'):  #output tab
            soutput+='\t'
      
        #maths
        elif(s[0]=='X'):
            #get sub command
            i=int(GetNextCharacters(instructions,Settings,2),16)
            #check if valid command
            if(i<0 or i>9):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid arithmetic operation. Must be 0 to 9")
      
            #where to store result
            result=int(GetNextCharacters(instructions,Settings,2),16)
            #check is valid resultlocation
            if(result<0 or (result>9 and result!=0x0C and result!=0x0E and result!=0x0F)):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"invalid arithmetic destination")
      
            #get first argument
            arga=GetNumberVarOrMemory(instructions,Vars,Settings,data,commandstart)
            #get 2nd argument if needed & keep compiler happy otherwise
            argb=GetNumberVarOrMemory(instructions,Vars,Settings,data,commandstart) if (i!=1) else 0
      
            #now process variables
            if(i==0):   #let
                k=arga
            elif(i==2): #add
                k=arga+argb
            elif(i==3): #subtract
                k=arga-argb
            elif(i==4): #multiply
                k=arga*argb
            elif(i==5): #divide
                k=arga/argb
            elif(i==6): #modulus
                k=arga%argb
            elif(i==7): #binary and
                k=arga&argb
            elif(i==8): #binary or
                k=arga|argb
            elif(i==9): #binary xor
                k=arga^argb
            else:
                k=0
      
            #ensure is 16 bit result
            k&=0xFFFF
      
            #save variable
            if(result==0x0F):
                Vars[0x0C]=k-Vars[0x0A]
            else:
                Vars[result]=k
      
        #flow
        elif(s[0]=='('):
            #process contents of brackets and combine result
            i,txt=ProcessCommandBlock(instructions,Vars,Settings,data,True,InTest,ReferencedLineNumbers)
            soutput+=txt
            boolState=CombineResults(boolMode,boolState,(i&1)==1)
            i=i&6
            #if break or continue, leave
            if(i!=0):
              #move to end of current block
              MoveToEndBlock(instructions,Vars,Settings,commandstart)
              #leave block
              return i+(1 if boolState else 0), soutput

        elif(s[0]==')'):
            #if not in brackets  then error
            if(not inBrackets):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"Closing brackets without opening brackets")
      
            #otherwise ought to return from command
            return 1 if boolState else 0, soutput
      
        elif(s[0]=='I'):  #if then block
            #should have brackets afterwards
            if(GetNextCharacters(instructions,Settings,2)!="%("):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"bracket bound test must follow if statement")
      
            #test if block
            result,txt=ProcessCommandBlock(instructions,Vars,Settings,data,True,True,ReferencedLineNumbers)
            bTest=(result&1)==1
            soutput+=txt
      
            #should have brackets afterwards for instruction block
            if(GetNextCharacters(instructions,Settings,2)!="%("):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"bracket bound action must follow if test")
      
            #signal no break or continue
            k=0
            #if contition met then process block
            if(bTest):
                k,txt=ProcessCommandBlock(instructions,Vars,Settings,data,True,InTest,ReferencedLineNumbers)
                soutput+=txt
                
            #otherwise move past command block
            else:
                MoveToEndBlock(instructions,Vars,Settings,commandstart)
      
            #save position before checking to see if is else statement following
            i=Settings["DATASTRINGPOS"]
            #see if is an else block
            if(GetNextCharacters(instructions,Settings,2)=="%J"):
                #should have brackets afterwards for instruction block
                if(GetNextCharacters(instructions,Settings,2)!="%("):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"bracket bound action must follow else statement")
                
                #process block
                k,txt=ProcessCommandBlock(instructions,Vars,Settings,data,True,InTest,ReferencedLineNumbers)
                soutput+=txt

            #otherwise reset string position
            else:
                Settings["DATASTRINGPOS"]=i
      
            #if break or continue happened inside if or else block then leave
            if((k&6)!=0):
                #move to end of current block
                MoveToEndBlock(instructions,Vars,Settings,commandstart)
                #leave block
                return k,soutput
      
        elif(s[0]=='L'):  #while do loop
            #should have brackets afterwards
            if(GetNextCharacters(instructions,Settings,2)!="%("):
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"bracket bound test must follow loop statement")
      
            #make note of where while do loop starts
            i=Settings["DATASTRINGPOS"]
      
            bTest=True
      
            #loop until test condition is false;
            while(bTest):
                #set where while do loop starts
                Settings["DATASTRINGPOS"]=i
            
                #test if block
                result,txt=ProcessCommandBlock(instructions,Vars,Settings,data,True,True,ReferencedLineNumbers)
                bTest=(result&1)==1
                soutput+=txt
            
                #should have brackets afterwards for instruction block
                if(GetNextCharacters(instructions,Settings,2)!="%("):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"bracket bound action must follow loop test")
            
                #if contition met then process block
                if(bTest):
                    result,txt=ProcessCommandBlock(instructions,Vars,Settings,data,True,InTest,ReferencedLineNumbers)
                    soutput+=txt
                    if((result&2)==2):
                        #if break from routine then break out of loop
            
                        #move to end of current block
                        MoveToEndBlock(instructions,Vars,Settings,commandstart)
            
                        break
            
                #otherwise move past command block
                if(not bTest):
                    MoveToEndBlock(instructions,Vars,Settings,commandstart)
      
        #end data block
        elif(s[0]=='Q'):
            #setting end of data block as current position, then ending line will quit data block
            Vars[0x0E]=Vars[0x0A]+Vars[0x0C]
      
            #by setting position to end of data string and returning, this will end line
            Settings["DATASTRINGPOS"]=len(instructions)
            return 1 if boolState else 0, soutput
      
        #end line
        elif(s[0]=='E'):
            #by setting position to end of data string and returning, this will end line
            Settings["DATASTRINGPOS"]=len(instructions)
            return 1 if boolState else 0, soutput
      
        #break;
        elif(s[0]=='Y'):
            #return
            return 3 if boolState else 2,soutput
      
        #continue
        elif(s[0]=='Z'):
            #return
            return 5 if boolState else 4,soutput
      
        #comparitors
        elif(s[0]=='?'):
            #get next chars
            comp=GetNextCharacters(instructions,Settings,2)
      
            #check if mode change
            if(comp[0]=='B'):
                if(comp[1]=='A'): #and
                    boolMode=0
                elif(comp[1]=='O'): #or
                    boolMode=1
                elif(comp[1]=='X'): #xor
                    boolMode=2
                else: #unrecognised mode command
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"unrecognised boolean combination mode")
      
                continue
                
            #have we tested enough already?
            #can we end testing based on results so far without further testing?
            if(InTest==True and (    #are we in a test situation?
               (boolMode==0 and boolState==False) or  #are we anding with false: answer will be false
               (boolMode==1 and boolState==True))     #are we oring with true: answer will be true
               ):
                #can leave test as have found answer
                #move to end of current block
                MoveToEndBlock(instructions,Vars,Settings,commandstart)
                #return from test block
                return 1 if boolState else 0, soutput
      
            #should now be tests
            #get which one
            i={"LT":0,"MT":1,"EQ":2,"LE":3,"ME":4,"NE":5}[comp]
            #throw NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"unrecognised comparison")
      
            #get 2 arguments
            arga=GetNumberVarOrMemory(instructions,Vars,Settings,data,commandstart)
            #get 2nd argument if needed
            argb=GetNumberVarOrMemory(instructions,Vars,Settings,data,commandstart)
      
            #now do text
            if(i==0):  #less than
                boolState=CombineResults(boolMode,boolState,arga<argb)
            elif(i==1):  #more than
                boolState=CombineResults(boolMode,boolState,arga>argb)
            elif(i==2):  #equal
                boolState=CombineResults(boolMode,boolState,arga==argb)
            elif(i==3):  #less than or equal
                boolState=CombineResults(boolMode,boolState,arga<=argb)
            elif(i==4):  #more than or equal
                boolState=CombineResults(boolMode,boolState,arga>=argb)
            elif(i==5):  #not equal
                boolState=CombineResults(boolMode,boolState,arga!=argb)
      
        #XML tags
        elif(s[0]=='$'):
            #default to normal tag
            emptytag=False
            closetag=False
            
            #get next char
            nextchar=GetNextCharacters(instructions,Settings,1)

            #check & handle empty tag
            if(nextchar=='$'):
                emptytag=True
                nextchar=GetNextCharacters(instructions,Settings,1)
            
            #check and handle closeing tag
            elif(nextchar=='-'):
                closetag=True
                nextchar=GetNextCharacters(instructions,Settings,1)
                
            #now figure out command
            if(nextchar=='A'):
                tag='address'
            
            elif(nextchar=='B'):
                tag='bytes'
            
            elif(nextchar=='C'):
                tag='comment'
                
            elif(nextchar=='D'):
                tag='data'
                
            elif(nextchar=='F'):
                tag='flags'
                
            elif(nextchar=='I'):
                tag='instruction'
            
            elif(nextchar=='L'):
                tag='line'
            
            elif(nextchar=='T'):
                tag='timeing'
            
            elif(nextchar=='<'):
                #get position of closeing bracket
                closepos=instructions.find(">",Settings["DATASTRINGPOS"])
                
                #handle no closeing bracket
                if(closepos==-1):
                    raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"no closeing bracket on XML tag")

                #get tag name from between brackets
                tag=instructions[Settings["DATASTRINGPOS"]:closepos]
                #update instructions position
                Settings["DATASTRINGPOS"]=closepos+1
            
            else:
                raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"unrecognised predefined XML tag")

            #if in xml mode then output tag
            if(Settings["XMLOutput"]==1):
                if(closetag==False and tag=='line'):
                    sputput+="  "
                    
                soutput+='<'
                
                if(closetag==True):
                    soutput+='/'

                soutput+=tag

                if(emptytag==True):
                    soutput+='/'

                soutput+='>'

        else: #unrecognised command
            raise NewSpectrumTranslateException(Vars[0x0A],commandstart,instructions,"unrecognised command")

    return 1 if boolState else 0, soutput

#generate exception 
def NewSpectrumTranslateException(address,pos,instructions,details):
    return SpectrumTranslateException('Data Format error processing "%s" near character number %d on line starting at %04X\n%s' % (instructions,pos,address,details))

#custom format bits 0&1=address, 2&3=number, 4&5=command, 6&7=tstates, 8&9+=line after jump
#A&B=linenumbers, C-13=lineeveryX, 14=emptylineafterdata, 15=referencedatanumbers
#16=listcommandbytes, 17=comments, 18=seperators, 19=ShowFlags, 1A=MarkUndocumenedCommand,
#1B=XMLOutput
def get_custom_format_string(AddressOutput,NumberOutput,CommandOutput,OutputTStates,BreakAfterJumps,LineNumberOutput,ListEveryXLines,BreakAfterData,TreatDataNumbersAsLineReferences,DisplayCommandBytes,DisplayComments,SeperatorMode,ShowFlags,MarkUndocumenedCommand,XMLOutput):
    """
    This method converts the various format settings into a String that can be used as an argument for
    the CustomFormat instruction in a DisassembleInstruction. You can pass the apropriate format
    instructions as arguments to this method: you can use the Address Output Format * instructions as the
    AddressOutput value to set the address format in the custom format. The same is true of the
    Number Output Format * instructions for NumberOutput, Command Output Format * for CommandOutput,
    Output T States Format * for OutputTStates, Line After Jump * for BreakAfterJumps,
    Line Numbers * for LineNumberOutput, Line Number Every X for ListEveryXLines, Empty Line After Data * for
    BreakAfterData, Reference Data Numbers * for TreatDataNumbersAsLineReferences, List Command Bytes * for
    DisplayCommandBytes, Comments * for DisplayComments, Seperators * for SeperatorMode, Display Flags * for
    ShowFlags, Mark Undocumented Command * for MarkUndocumenedCommand, and XML Output * for XMLOutput.
   
    AddressOutput is the format of the address at the begining of the line.
    NumberOutput is the format of numbers being displayed.
    CommandOutput is the format of the bytes of a command being displayed.
    OutputTStates is how the command lengths are displayed.
    BreakAfterJumps is if a blank line after a jump or return is displayed.
    LineNumberOutput is which line addresses are displayed.
    ListEveryXLines is if line addresses are displayed every X lines & their spacing.
    BreakAfterData is if a blank line is displayed after a data block.
    TreatDataNumbersAsLineReferences is if numbers in data are used as line references.
    DisplayCommandBytes is whether the bytes making up a command are displayed.
    DisplayComments is whether comments (and thus flags, timings, and undocumented command
        notification) are displayed.
    SeperatorMode is the seperator.
    ShowFlags is whether flags are displayed or not.
    MarkUndocumenedCommand is if undocumented commands are noted.
    XMLOutput is if outputting as XML or not.
    
    Returns a string version of the settings as a hexadecimal number usable with a CustomFormat instruction.
    """
    
    i=(AddressOutput&3)+((NumberOutput&3)<<2)+((CommandOutput&3)<<4)+((OutputTStates&3)<<6)
    i+=((BreakAfterJumps&3)<<8)+((LineNumberOutput&3)<<0x0A)+((ListEveryXLines&255)<<0x0C)
    i+=((BreakAfterData&1)<<0x14)+((TreatDataNumbersAsLineReferences&1)<<0x15)
    i+=((DisplayCommandBytes&1)<<0x16)+((DisplayComments&1)<<0x17)+((SeperatorMode&1)<<0x18)
    i+=((ShowFlags&1)<<0x19)+((MarkUndocumenedCommand&1)<<0x1A)+((XMLOutput&1)<<0x1B)
    
    return "%X" % i

def get_custom_format_values(data,bWantInstructionCode=False):
    """
    This method extracts the various format settings from a String that is the argument for the
    CustomFormat instruction in a DisassembleInstruction. The values for the various
    settings are absolute values. The values are intended for use by SpectrumFileTranslate
    and SpectrumFileTranslateGUI. Set the bWantInstructionCode option to True if you want
    the returned values to be valid DisassembleInstruction instruction codes.
   
    data is the data variable from a CustomFormat instruction.
    bWantInstructionCode is True if you want the returned values to be valid
    instructions (other than number 6: how often to display unreferenced lines) which should be
    converted to a String and used as the argument for a LineNumberEvery_X instruction.Otherwise
    it simply returns absolute values of more use to internal methods.
    
    returns a tupple14 int array. The values in order (so result[0] would be the first setting,
    result[1] would be the second etc.) are: The number format of address at the beginning of a
    line, The number format for numbers being displayed, The format of the bytes of a command,
    The format for command timings, When to display an empty line after jumps, Which linee numbers
    to display, How often to display line numbers not refferenced, If you want blank lines after
    data blocks, Whether to treat numbers in data as line references, Whether to display the bytes
    of commands, Whether to display comments, What type of separator to use, Whether to show flags,
    Whether to mark undocumented commands.
    """
    
    i=int(data,16)

    ret={
        "AddressOutput":i&0x03,
        "NumberOutput":(i>>2)&0x03,
        "CommandOutput":(i>>4)&0x03,
        "OutputTStates":(i>>6)&0x03,
        "BreakAfterJumps":(i>>8)&0x03,
        "LineNumberOutput":(i>>0xA)&0x03,
        "ListEveryXLines":(i>>0xC)&0xFF,
        "BreakAfterData":(i>>0x14)&0x01,
        "TreatDataNumbersAsLineReferences":(i>>0x15)&0x01,
        "DisplayCommandBytes":(i>>0x16)&0x01,
        "DisplayComments":(i>>0x17)&0x01,
        "SeperatorMode":(i>>0x18)&0x01,
        "ShowFlags":(i>>0x19)&0x01,
        "MarkUndocumenedCommand":(i>>0x1A)&0x01,
        "XMLOutput":(i>>0x1B)&0x01
        }

    #convert results to instruction codes if requested
    if(bWantInstructionCode):
        ret["AddressOutput"]|=DisassembleInstruction.DisassembleCodes["Address Output Format Hex"]
        ret["NumberOutput"]|=DisassembleInstruction.DisassembleCodes["Number Output Format Hex"]
        ret["CommandOutput"]|=DisassembleInstruction.DisassembleCodes["Command Output Format Hex"]
        ret["OutputTStates"]|=DisassembleInstruction.DisassembleCodes["Output T States Format None"]
        ret["BreakAfterJumps"]|=DisassembleInstruction.DisassembleCodes["Line After Jump None"]
        ret["LineNumberOutput"]|=DisassembleInstruction.DisassembleCodes["Line Numbers All"]
        ret["BreakAfterData"]|=DisassembleInstruction.DisassembleCodes["Empty Line After Data On"]
        ret["TreatDataNumbersAsLineReferences"]|=DisassembleInstruction.DisassembleCodes["Reference Data Numbers On"]
        ret["DisplayCommandBytes"]|=DisassembleInstruction.DisassembleCodes["List Command Bytes On"]
        ret["DisplayComments"]|=DisassembleInstruction.DisassembleCodes["Comments On"]
        ret["SeperatorMode"]|=DisassembleInstruction.DisassembleCodes["Seperators Space"]
        ret["ShowFlags"]|=DisassembleInstruction.DisassembleCodes["Display Flags Off"]
        ret["MarkUndocumenedCommand"]|=DisassembleInstruction.DisassembleCodes["Mark Undocumented Command Off"]
        ret["XMLOutput"]|=DisassembleInstruction.DisassembleCodes["XML Output Off"]

    return ret


def GetPartsOfPatternDataBlock(pdb):
    """
    Returns list of the 3 parts of of a patternDataBlock.
    """

    #nested function to move past any comments
    def PassCommentIfNeeded(instructions,Settings):
        #remember where we are
        pos=Settings["DATASTRINGPOS"]
        
        s=""

        #loop until have next 2 characters of non whitespace characters or hit end of commands, or end of line
        while(len(s)<2 and Settings["DATASTRINGPOS"]<len(instructions)):
            c=instructions[Settings["DATASTRINGPOS"]]
        
            #ignore whitespace but not newline
            if(c!=' ' and c!='\t'):
                s+=c
                
            Settings["DATASTRINGPOS"]+=1
            
        #is next thing a comment?
        if(s=="%#"):
            #if so move past it
            Settings["DATASTRINGPOS"]=instructions.find("\n",Settings["DATASTRINGPOS"])
            #if newline not found,
            if(Settings["DATASTRINGPOS"]==-1):
                #set to end of line
                Settings["DATASTRINGPOS"]=len(instructions)
        
        else:
            #otherwise reset position
            Settings["DATASTRINGPOS"]=pos



    #break Pattern Data Block into sections
    test=None
    prep=None
    action=None

    try:
        Settings={"DATASTRINGPOS":0}
        Vars=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0xFFFF]
        
        #first check is valid test block & record where
        s=GetNextCharacters(pdb,Settings,2)
        if(s!="%("):
            return (test,prep,action)
            
        #record test start
        k=Settings["DATASTRINGPOS"]
        #move to end of test block
        MoveToEndBlock(pdb,Vars,Settings,0)
        #move past comment if one exists on same line as close block
        PassCommentIfNeeded(pdb,Settings)
        #calculate test string
        test="%("+pdb[k:Settings["DATASTRINGPOS"]]
        
        #now check is valid preperation block & record where
        s=GetNextCharacters(pdb,Settings,2)
        if(s!="%("):
            return (test,prep,action)
        
        #record preperation block start
        k=Settings["DATASTRINGPOS"]
        #move to end of preperation block
        MoveToEndBlock(pdb,Vars,Settings,0)
        #move past comment if one exists on same line as close block
        PassCommentIfNeeded(pdb,Settings)
        #calculate preperation string
        prep="%("+pdb[k:Settings["DATASTRINGPOS"]]
        
        #calculate action string
        action=pdb[Settings["DATASTRINGPOS"]:]
        
        return (test,prep,action)
        
    except:
        return (test,prep,action)

#todo
#remove once finished debugging.
#remove references to this also
def _logString(s):
    fo=open("py_debug.txt","a")
    fo.write(s)
    fo.close()
    

class SpectrumTranslateException(Exception):
    """
    A class to flag up an Exception raised during woring with SpectrumTranslate objects
    """
    
    def __init__(self,arg):
        self.value=arg
    
    def __str__(self):
        return repr(self.value)

if __name__=="__main__":
    #print get_spectrum_string("\x7F\x60\x5E\xF0\xF2")

    """
    import spectrumtapblock    
    tbs=spectrumtapblock.get_TapBlocks('/home/william/RR.tap/REBRAID1.TAP')
    for (i,tb) in enumerate(tbs):
        #if(not tb.is_headder() or not "Program" in tb.get_file_type_string()):
        #    print tb
        #    continue
            
        if(not tb.is_headder() or not "Bytes" in tb.get_file_type_string()):
            print tb
            continue

        print "%i %s" % (i,tb.get_file_details_string())
        #print "%X" % tbs[i+1].filePosition
    """
    
    #display contents of aray
    #x=8
    #print convert_array_to_text(tbs[x+1].data,tbs[x].get_headder_array_descriptor())
    #print str(tbs[x+1].getbytes())

    #display content of program
    #x=4
    #print convert_program_to_text(tbs[x+1].data,tbs[x].get_headder_autostart_line(),tbs[x].get_headder_variable_offset())
    #print str(tbs[x+1].getbytes())

    """
    #get image
    x=26

    import os
    #os.remove("py_debug.txt")    
    fo=open("x1.gif","wb")
    fo.write(get_GIF_from_screen(tbs[x+1].data))
    fo.close()
    """

    """
    #dissassemble code
    x=2
    fo=open("x.txt","wb")
    fo.write(disassemble(tbs[x+1].data,0,tbs[x].get_headder_code_start(),tbs[x].get_headder_described_data_length()))
    fo.close()
    #print str(tbs[x+1].getbytes())
    """

    #print str(tbs[x+1].getbytes())

    #testsplit
    print DisassembleInstruction.DisassemblePatternBlockCodes["RST#28 (Calculator)"]
    x=GetPartsOfPatternDataBlock(DisassembleInstruction.DisassemblePatternBlockCodes["RST#28 (Calculator)"])
    print x
    print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    print x[0]
    print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    print x[1]
    print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    print x[2]
    print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    
    """
    #test translate macine code
    diInstructions=[DisassembleInstruction(DisassembleInstruction.DisassembleCodes["Custom Format"],
        0,
        0xFFFF,
        get_custom_format_string(0,
            0,
            0,
            0,
            1,
            DisassembleInstruction.DisassembleCodes["Line Numbers Referenced"],
            16,
            DisassembleInstruction.DisassembleCodes["Empty Line After Data On"],
            DisassembleInstruction.DisassembleCodes["Reference Data Numbers On"],
            DisassembleInstruction.DisassembleCodes["List Command Bytes On"],
            DisassembleInstruction.DisassembleCodes["Comments Off"],
            DisassembleInstruction.DisassembleCodes["Seperators Space"],
            DisassembleInstruction.DisassembleCodes["Display Flags Off"],
            DisassembleInstruction.DisassembleCodes["Mark Undocumented Command Off"],
            DisassembleInstruction.DisassembleCodes["XML Output On"]))]

    """
    #DisassembleInstruction("""10000#754D#10000#6,B,16,21,26,35,38,3B,42,96,9F,F3,F8,FD,103,116,11B,122,125,12A,139,13C,13F,143#%F0004%ACA%S%S DM %S%X01000000%L%(  %?LE%V0F%V0E%)%(  %I%(    %(%?EQ%V000001 %?BA %(%?LT%MV0F0020 %?BO %(%?MT%MV0F007F%?BA%?LT%MV0F00A3%)%)%)    %?BO    %(%?EQ%V000000 %?BA %(%?MT%MV0F00A2 %?BO %(%?MT%MV0F001F%?BA%?LT%MV0F0080%)%)%)  %)  %(    "    %X03000001%V00  %)  %C0F%)%I%(  %?EQ%V000001%)%(  "%)""")]
    #DisassembleInstruction("""10000#754D#10000#6,B,16,21,26,4A,4D,50,57,AB,B4,108,10D,11A,120,133,138,13F,142,147,156,159,15C,160#%F0004%ACA%S%S DM %S%X01000000%L%(  %?LE%V0F%V0E            %#testing%)%(  %I%(    %(%?EQ%V000001 %?BA %(%?LT%MV0F0020 %?BO %(%?MT%MV0F007F%?BA%?LT%MV0F00A3%)%)%)    %?BO    %(%?EQ%V000000 %?BA %(%?MT%MV0F00A2 %?BO %(%?MT%MV0F001F%?BA%?LT%MV0F0080%)%)%)  %)  %(  %#test    "    %X03000001%V00  %)  %C0F%)%I%(  %?EQ%V000001%)%(  "%)""")]
    #data='\xdd!\x00\x80\x11\x0e\x00\xcdBu\xdd!\x0e\x80\xed[\x0b\x80\xaf=\xcd\xc2\x04\x06\x19v\x10\xfd\xc9LPICTITLGAM1GAM2MSFXBAN4L0MAL0DEL0REL0ALL0B0L0B1L1MAL1DEL1REL1ALL1B0L1B1L2MAL2DEL2REL2ALL2B0L2B1L3MAL3DEL3REL3ALL3B0L3B1L4MAL4DEL4REL4ALL4B1'
    #print disassemble(data,0,0x7530,len(data),diInstructions)
     
